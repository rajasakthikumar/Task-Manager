File: bootstrap.js
----------------------------------------
const TaskRepository = require('./repositories/task');
const CommentRepository = require('./repositories/comment');
const TaskService = require('./services/task');
const TaskController = require('./controllers/task');
const StatusRepository = require('./repositories/status');
const StatusService = require('./services/status');
const StatusController = require('./controllers/status');
const UserRepository = require('./repositories/user');
const UserService = require('./services/user');
const UserController = require('./controllers/user');
const RoleRepository = require('./repositories/role');
const RoleService = require('./services/role');
const RoleController = require('./controllers/role');
const AuditLogRepository = require('./repositories/auditLog');
const AuditLogService = require('./services/auditLog');
const CommentController = require('./controllers/comment');
const CommentService = require('./services/comment');

const taskRepository = new TaskRepository();
const commentRepository = new CommentRepository();
const statusRepository = new StatusRepository();
const userRepository = new UserRepository();
const roleRepository = new RoleRepository();
const auditLogRepository = new AuditLogRepository();

const taskService = new TaskService(taskRepository, commentRepository);
const statusService = new StatusService(statusRepository, auditLogRepository);
const userService = new UserService(userRepository,roleRepository);
const roleService = new RoleService(roleRepository);
const auditLogService = new AuditLogService(auditLogRepository);
const commentService = new CommentService(commentRepository);

const taskController = new TaskController(taskService);
const statusController = new StatusController(statusService);
const userController = new UserController(userService);
const roleController = new RoleController(roleService);
const commentController = new CommentController(commentService);

module.exports = {
    taskController,
    statusController,
    userController,
    roleController,
    commentController
};

File: config\db.js
----------------------------------------
// config/db.js
const mongoose = require('mongoose');
const dotenv = require('dotenv');

dotenv.config();
const uri = process.env.DBURI;

if (!uri) {
  throw new Error(' Make sure DBURI is not defined.');
}

mongoose
  .connect(uri, {
    useNewUrlParser: true,
    useUnifiedTopology: true
  })
  .then(() => console.log('MongoDB connected'))
  .catch(err =>
    console.error('Error connecting to MongoDB:', err)
  );


File: controllers\comment.js
----------------------------------------
const asyncHandler = require('../middleware/asynchandler');
const CommentService = require('../services/comment');
const CommentRepository = require('../repositories/comment');
const path = require('path');
const fs = require('fs');

class CommentController {
    constructor() {
        const commentRepository = new CommentRepository();
        this.commentService = new CommentService(commentRepository);
    }

    addComment = asyncHandler(async (req, res) => {
        const { taskId } = req.params;
        const { text } = req.body;

        const attachments = req.files
            ? req.files.map(file => ({
                  filename: file.filename,
                  filepath: file.path
              }))
            : [];

        const newComment = await this.commentService.create({
            text,
            createdBy: req.user._id,
            task: taskId,
            attachments
        });

        res.status(201).json(newComment);
    });

    addAttachmentsToComment = asyncHandler(async (req, res) => {
        const { commentId } = req.params;

        const attachments = req.files.map(file => ({
            filename: file.filename,
            filepath: file.path
        }));

        const updatedComment = await this.commentService.addAttachmentToComment(
            commentId,
            attachments
        );

        res.status(200).json(updatedComment);
    });

    downloadAttachment = asyncHandler(async (req, res) => {
        const { commentId, attachmentId } = req.params;
        const comment = await this.commentService.findById(commentId);

        if (!comment) {
            return res.status(404).json({ message: 'Comment not found' });
        }

        const attachment = comment.attachments.id(attachmentId);
        if (!attachment) {
            return res.status(404).json({ message: 'Attachment not found' });
        }

        const filePath = path.resolve(attachment.filepath);
        res.download(filePath, attachment.filename);
    });

    deleteAttachment = asyncHandler(async (req, res) => {
        const { commentId, attachmentId } = req.params;
        const updatedComment = await this.commentService.deleteAttachment(
            commentId,
            attachmentId
        );

        res.status(200).json(updatedComment);
    });
}

module.exports = CommentController;


File: controllers\role.js
----------------------------------------
const asyncHandler = require('../middleware/asynchandler');
const CustomError = require('../util/customError');

class RoleController {
    constructor(roleService) {
        this.roleService = roleService;
    }

    createRole = asyncHandler(async (req, res,next) => {
        const {role} = req.body;
        if(role == "president") {
            next(new CustomError("Cannot create this role",400));
        }
        console.log(req.body);
        let roles = await this.roleService.createRole(req.body);
        res.status(201).json(roles);
    });

    getAllRoles = asyncHandler(async (req, res) => {
        const roles = await this.roleService.getAllRoles();
        res.status(200).json(roles);
    });

    getRoleById = asyncHandler(async (req, res) => {
        const role = await this.roleService.getRoleById(req.params.id);
        res.status(200).json(role);
    });
}

module.exports = RoleController;


File: controllers\status.js
----------------------------------------
const asyncHandler = require('../middleware/asynchandler');

class StatusController {
    constructor(service) {
        this.service = service;
    }

    getAllStatus = asyncHandler(async (req, res) => {
        const statuses = await this.service.getAllStatus(req.user);
        res.status(200).json(statuses);
    });

    getDeletedStatuses = asyncHandler(async (req, res) => {
        const statuses = await this.service.getDeletedStatuses(req.user);
        res.status(200).json(statuses);
    });

    findStatusById = asyncHandler(async (req, res) => {
        const id = req.params.id;
        const status = await this.service.findById(id, req.user);
        res.status(200).json(status);
    });

    createStatus = asyncHandler(async (req, res) => {
        const status = await this.service.createStatus(
            req.body,
            req.user
        );
        res.status(201).json(status);
    });

    deleteStatus = asyncHandler(async (req, res) => {
        const id = req.params.id;
        await this.service.deleteStatus(id, req.user);
        res.status(200).json({
            message: 'Status soft deleted successfully'
        });
    });

    restoreStatus = asyncHandler(async (req, res) => {
        const id = req.params.id;
        const restoredStatus = await this.service.restoreStatus(
            id,
            req.user
        );
        res.status(200).json({
            message: 'Status restored successfully',
            restoredStatus
        });
    });

    hardDeleteStatus = asyncHandler(async (req, res) => {
        const id = req.params.id;
        await this.service.hardDeleteStatus(id, req.user);
        res.status(200).json({
            message: 'Status permanently deleted successfully'
        });
    });

    modifyStatus = asyncHandler(async (req, res) => {
        const id = req.params.id;
        const bodyToModify = req.body;
        const modifiedStatus = await this.service.modifyStatus(
            id,
            bodyToModify,
            req.user
        );
        res.status(200).json(modifiedStatus);
    });

    addNextStatus = asyncHandler(async (req, res) => {
        const { id } = req.params;
        const { nextStatusId } = req.body;
        const status = await this.service.addNextStatus(
            id,
            nextStatusId,
            req.user
        );
        res.status(200).json(status);
    });

    addPrevStatus = asyncHandler(async (req, res) => {
        const { id } = req.params;
        const { prevStatusId } = req.body;
        const status = await this.service.addPrevStatus(
            id,
            prevStatusId,
            req.user
        );
        res.status(200).json(status);
    });

    validateTransition = asyncHandler(async (req, res) => {
        const { currentStatusId, nextStatusId } = req.params;
        await this.service.validateTransition(
            currentStatusId,
            nextStatusId,
            req.user
        );
        res.status(200).json({ message: 'Status transition is valid' });
    });
}

module.exports = StatusController;


File: controllers\task.js
----------------------------------------
// controllers/task.js
const asyncHandler = require('../middleware/asynchandler');

class TaskController {
    constructor(service) {
        this.service = service;
        console.log('Task Controller created');
    }

    getAllTasks = asyncHandler(async (req, res) => {
        const tasks = await this.service.getAllTasks(req.user);
        res.status(200).json(tasks);
    });

    getTaskById = asyncHandler(async (req, res) => {
        const task = await this.service.findById(req.params.id, req.user);
        res.status(200).json(task);
    });

    createTask = asyncHandler(async (req, res) => {
        const taskData = { ...req.body };
        const assignedToId = req.body.assignedTo || null;
        const createdTask = await this.service.createTask(
            taskData,
            req.user,
            assignedToId
        );
        res.status(201).json(createdTask);
    });

    updateTask = asyncHandler(async (req, res) => {
        const updatedTask = await this.service.updateTask(
            req.params.id,
            req.body,
            req.user
        );
        res.status(200).json(updatedTask);
    });

    updateTaskStatus = asyncHandler(async (req, res) => {
        const { taskId, statusId } = req.params;
        const updatedTask = await this.service.updateTaskStatus(
            taskId,
            statusId,
            req.user
        );
        res.status(200).json(updatedTask);
    });

    deleteTask = asyncHandler(async (req, res) => {
        const deletedTask = await this.service.deleteTask(
            req.params.id,
            req.user
        );
        res.status(200).json({
            message: 'Task deleted successfully',
            deletedTask
        });
    });

    assignTask = asyncHandler(async (req, res) => {
        const { id } = req.params;
        const { assignedToId } = req.body;
        const updatedTask = await this.service.assignTask(
            id,
            req.user._id,
            assignedToId
        );
        res.status(200).json(updatedTask);
    });

    addComment = asyncHandler(async (req, res) => {
        const { taskId } = req.params;
        const { text } = req.body;
        const newComment = await this.service.addComment(
            taskId,
            req.user,
            text
        );
        res.status(201).json(newComment);
    });

    getTasksByPriority = asyncHandler(async (req, res) => {
        const { priority } = req.params;
        const tasks = await this.service.getTasksByPriority(
            req.user,
            priority
        );
        res.status(200).json(tasks);
    });

    updateTaskPriority = asyncHandler(async (req, res) => {
        const { id } = req.params;
        const { priority } = req.body;
        const updatedTask = await this.service.updateTaskPriority(
            id,
            req.user,
            priority
        );
        res.status(200).json(updatedTask);
    });

    getTasksAssignedTo = asyncHandler(async (req, res) => {
        const tasks = await this.service.getTasksAssignedTo(req.user);
        res.status(200).json(tasks);
    });

    getTasksCreatedBy = asyncHandler(async (req, res) => {
        const tasks = await this.service.getTasksCreatedBy(req.user);
        res.status(200).json(tasks);
    });

    softDeleteTask = asyncHandler(async (req, res) => {
        const deletedTask = await this.service.softDeleteTask(
            req.params.id,
            req.user
        );
        res.status(200).json({
            message: 'Task soft deleted successfully',
            deletedTask
        });
    });

    restoreTask = asyncHandler(async (req, res) => {
        const restoredTask = await this.service.restoreTask(
            req.params.id,
            req.user
        );
        res.status(200).json({
            message: 'Task restored successfully',
            restoredTask
        });
    });

    getDeletedTasks = asyncHandler(async (req, res) => {
        const tasks = await this.service.getDeletedTasks(req.user);
        res.status(200).json(tasks);
    });

    getTasksByStatus = asyncHandler(async (req, res) => {
        const { statusId } = req.params;
        const tasks = await this.service.getTasksByStatus(
            req.user,
            statusId
        );
        res.status(200).json(tasks);
    });

    getTasksByDateRange = asyncHandler(async (req, res) => {
        const { startDate, endDate } = req.body;
        const tasks = await this.service.getTasksByDateRange(
            req.user,
            startDate,
            endDate
        );
        res.status(200).json(tasks);
    });

    searchTasks = asyncHandler(async (req, res) => {
        const { searchTerm } = req.params;
        const tasks = await this.service.searchTasks(req.user, searchTerm);
        res.status(200).json(tasks);
    });

    getOverdueTasks = asyncHandler(async (req, res) => {
        const tasks = await this.service.getOverdueTasks(req.user);
        res.status(200).json(tasks);
    });

    getTasksDueToday = asyncHandler(async (req, res) => {
        const tasks = await this.service.getTasksDueToday(req.user);
        res.status(200).json(tasks);
    });

    unassignTask = asyncHandler(async (req, res) => {
        const { id } = req.params;
        const updatedTask = await this.service.unassignTask(id, req.user);
        res.status(200).json(updatedTask);
    });

    updateTaskEndDate = asyncHandler(async (req, res) => {
        const { id } = req.params;
        const { endDate } = req.body;
        const updatedTask = await this.service.updateTaskEndDate(
            id,
            req.user,
            endDate
        );
        res.status(200).json(updatedTask);
    });
}

module.exports = TaskController;


File: controllers\user.js
----------------------------------------
const asyncHandler = require('../middleware/asynchandler');
const CustomError = require('../util/customError');

class UserController {
    constructor(userService) {
        this.userService = userService;
        console.log('User Controller created');
    }

    registerUser = asyncHandler(async (req, res) => {
        const { username, email, password,roles } = req.body;
        console.log(`@!@!@!@!@! USerController ${username}`);

        const user = await this.userService.registerUser({
            username,
            email,
            password,
            roles
        });

        console.log(`@!@!@!@! registerUSer Called`)
        res.status(201).json(user);
    });

    loginUser = asyncHandler(async (req, res) => {
        const { username, password } = req.body;
        const user = await this.userService.loginUser(
            username,
            password
        );
        res.status(200).json(user);
    });

    getUserById = asyncHandler(async (req, res) => {
        const userId = req.params.id;
        const user = await this.userService.getUserById(userId);
        res.status(200).json(user);
    });

    getAllUsers = asyncHandler(async (req, res) => {
        const users = await this.userService.getAllUsers();
        res.status(200).json(users);
    });

    assignRole = asyncHandler(async (req, res) => {
        const { userId, roles } = req.body;
        console.log("@!@!@!@! userController",userId ,roles)
        const updatedUser = await this.userService.assignRole(userId, roles);
        res.status(200).json(updatedUser);
    });
}

module.exports = UserController;


File: index.js
----------------------------------------
const express = require('express');
const dotenv = require('dotenv');
const helmet = require('helmet');
const morgan = require('morgan');
const CustomError = require('./util/customError');
const taskRoutes = require('./routes/task');
const statusRoutes = require('./routes/status');
const userRoutes = require('./routes/user');
const roleRoutes = require('./routes/role');
// const commentRoutes = require('./routes/comment');

const seedPermissionsAndRoles = require('./seed');

dotenv.config();

const app = express();
app.use(express.json());


// Mount routes
app.use('/api/tasks', taskRoutes);
app.use('/api/status', statusRoutes);
app.use('/api/users', userRoutes);
app.use('/api/roles', roleRoutes);
// app.use('/api', commentRoutes);

app.use((err, req, res, next) => {
    if (err instanceof CustomError) {
        CustomError.handleError(err, res);
    } else {
        res.status(500).json({
            success: false,
            message: 'Internal Server Error'
        });
    }
});

const startServer = async () => {
    try {
        await require('./config/db'); 
        await seedPermissionsAndRoles(); 
        app.listen(PORT, () => {
            console.log(`Server running on port ${PORT}`);
        });
    } catch (error) {
        console.error('Failed to start server:', error);
    }
};

startServer();

File: middleware\asynchandler.js
----------------------------------------
const asyncHandler = fn => (req,res,next) => {
    Promise.resolve(fn(req,res,next)).catch(next);
}
module.exports = asyncHandler

File: middleware\auth.js
----------------------------------------
const jwt = require('jsonwebtoken');
const User = require('../models/user');
const asyncHandler = require('./asynchandler');

const protect = asyncHandler(async (req, res, next) => {
    let token;

    if (
        req.headers.authorization &&
        req.headers.authorization.startsWith('Bearer')
    ) {
        token = req.headers.authorization.split(' ')[1];
    }
    if (!token) {
        return res.status(401).json({
            message: 'Not authorized, no token'
        });
    }

    try {
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        req.user = await User.findById(decoded.id).select('-password');

        if (!req.user) {
            return res.status(401).json({
                message: 'Not authorized, user not found'
            });
        }

        next();
    } catch (error) {
        console.error('Auth error:', error);
        res.status(401).json({
            message: 'Not authorized, token failed'
        });
    }
});

const authorize = (...requiredPermissions) => {
    return asyncHandler(async (req, res, next) => {
        const userPermissions = req.user.roles.flatMap(role => role.permissions.map(p => p.name));
        const hasPermission = requiredPermissions.every(permission => userPermissions.includes(permission));
        if (!hasPermission) {
            return res.status(403).json({ message: 'You do not have  required permissions' });
        }
        next();
    });
};

module.exports = { protect, authorize };


File: middleware\errorHandler.js
----------------------------------------
const CustomError = require("../util/customError");

const errorHandler = (err,req,res,next) => {
    console.error('Error:' ,err);

    if(err instanceof CustomError) {
        return CustomError.handleError(err,res);
    }

    res.status(500).json({
        success: false,
        message: 'Something went wrong'
    });
}

module.exports = errorHandler;

File: middleware\permissions.js
----------------------------------------
const asyncHandler = require('./asynchandler');

const permissionsCheck = requiredPermissions => {
    return asyncHandler(async (req, res, next) => {
        if (!req.user) {
            return res.status(401).json({ message: 'Not authorized' });
        }
        await req.user.populate('roles').execPopulate();
        const userPermissions = req.user.roles.flatMap(
            role => role.permissions
        );
        const hasPermission = requiredPermissions.every(permission =>
            userPermissions.includes(permission)
        );
        if (!hasPermission) {
            return res.status(403).json({
                message: 'Warning: you do not have the necessary permissions'
            });
        }
        next();
    });
};

module.exports = { permissionsCheck };


File: middleware\rateLimit.js
----------------------------------------
const rateLimit = require('express-rate-limit');

const limiter = rateLimit({
    windowMs: 15 * 60 * 1000,
    max: 100,
    message:
        'Too many requests from this '
});

module.exports = limiter;


File: middleware\upload.js
----------------------------------------
const multer = require('multer');
const path = require('path');
const fs = require('fs');

const uploadDirectory = path.join(__dirname, '..', 'uploads');
if (!fs.existsSync(uploadDirectory)) {
    fs.mkdirSync(uploadDirectory, { recursive: true });
}

const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        cb(null, uploadDirectory);
    },
    filename: (req, file, cb) => {
        const uniqueSuffix = `${Date.now()}-${Math.round(
            Math.random() * 1e9
        )}${path.extname(file.originalname)}`;
        cb(null, `${uniqueSuffix}`);
    }
});

const fileFilter = (req, file, cb) => {
    const allowedMimeTypes = [
        'image/jpeg',
        'image/jpg',
        'image/png',
        'application/pdf',
        'application/msword',
        'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
    ];

    if (allowedMimeTypes.includes(file.mimetype)) {
        cb(null, true);
    } else {
        cb(
            new Error(
                'Unsupported file type. Only images and documents are allowed.'
            )
        );
    }
};

const upload = multer({
    storage,
    limits: { fileSize: 5 * 1024 * 1024 },
    fileFilter
});

module.exports = {
    uploadSingle: upload.single('attachment'),
};


File: models\auditLog.js
----------------------------------------
const mongoose = require('mongoose');

const auditLogSchema = new mongoose.Schema({
    action: {
        type: String,
        required: true
    },
    performedBy: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: true
    },
    entity: {
        type: String,
        required: true
    },
    entityId: {
        type: mongoose.Schema.Types.ObjectId,
        required: true
    },
    changes: {
        type: Object
    },
    timestamp: {
        type: Date,
        default: Date.now
    }
});

module.exports = mongoose.model('AuditLog', auditLogSchema);


File: models\comment.js
----------------------------------------
const mongoose = require('mongoose');

const attachmentSchema = new mongoose.Schema({
    filename: String,
    filepath: String
});

const commentSchema = new mongoose.Schema({
    text: {
        type: String,
        required: true,
        trim: true
    },
    createdBy: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: true
    },
    task: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Task',
        required: true
    },
    createdAt: {
        type: Date,
        default: Date.now
    },
    attachments: [attachmentSchema]
});

module.exports = mongoose.model('Comment', commentSchema);


File: models\payment.js
----------------------------------------
const mongoose = require('mongoose');

const paymentSchema = new mongoose.Schema({
    tier:{
        type: String,
        required: true ,

    },amount:{
        type: Number,
        required: true
    },
    paymentDate:{
        type: Date,
        default: Date.now
    },
    nextPaymentDate:{
        type: Date,
        required: true,
    },
    paymentType:{
        type: String,
        required: true,
        enum:["credit","debit"],
        default: "credit"
    }
});

module.exports = mongoose.model('Payment', paymentSchema)

File: models\permission.js
----------------------------------------
const mongoose = require('mongoose');

const permissionSchema = new mongoose.Schema({
    name: {
        type: String,
        required: true,
        unique: true,
        trim: true
    },
    description: {
        type: String,
        trim: true
    },
    createdAt: {
        type: Date,
        default: Date.now
    }
});

module.exports = mongoose.model('Permission', permissionSchema);


File: models\role.js
----------------------------------------
const mongoose = require('mongoose');

const roleSchema = new mongoose.Schema({
    name: {
        type: String,
        required: true,
        unique: true,
        trim: true
    },
    permissions: [
        {
            type: mongoose.Schema.Types.ObjectId,
            ref: 'Permission',
            required: false
        }
    ],
    createdAt: {
        type: Date,
        default: Date.now
    }
});

module.exports = mongoose.model('Role', roleSchema);


File: models\status.js
----------------------------------------
const mongoose = require('mongoose');

const statusSchema = new mongoose.Schema({
    statusName: {
        type: String,
        required: true,
        unique: true,
        trim: true
    },
    createdBy: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: true
    },
    isDeleted: {
        type: Boolean,
        default: false
    },
    deletedAt: Date,
    nextStatuses: [
        {
            type: mongoose.Schema.Types.ObjectId,
            ref: 'Status'
        }
    ],
    prevStatuses: [
        {
            type: mongoose.Schema.Types.ObjectId,
            ref: 'Status'
        }
    ],
    createdAt: {
        type: Date,
        default: Date.now
    },
    modifiedAt: Date
});

module.exports = mongoose.model('Status', statusSchema);


File: models\task.js
----------------------------------------
const mongoose = require('mongoose');

const taskSchema = new mongoose.Schema({
    title: {
        type: String,
        required: true,
        trim: true
    },
    description: String,
    status: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Status',
        required: true
    },
    createdDate: {
        type: Date,
        default: Date.now
    },
    endDate: Date,
    modifiedDate: Date,
    user: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: true
    },
    assignedTo: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User'
    },
    comments: [
        {
            type: mongoose.Schema.Types.ObjectId,
            ref: 'Comment'
        }
    ],
    priority: {
        type: String,
        enum: ['low', 'medium', 'high'],
        default: 'low'
    },
    isDeleted: {
        type: Boolean,
        default: false
    },
    deletedDate: {
        type: Date
    }
});

module.exports = mongoose.model('Task', taskSchema);


File: models\user.js
----------------------------------------
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const userSchema = new mongoose.Schema({
    username: {
        type: String,
        required: true,
        unique: true,
        trim: true
    },
    email: { 
        type: String,
        required: false,
        unique: true,
        trim: true
    },
    password: {
        type: String,
        required: true
    },
    roles: [
        {
            type: mongoose.Schema.Types.ObjectId,
            ref: 'Role',
            required: false
        }
    ],
    createdAt: {
        type: Date,
        default: Date.now
    },
    isPayed:{
        type:Boolean,
        required:true,
        default:false
    }
});

userSchema.pre('save', async function (next) {
    if (!this.isModified('password')) return next();
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
});

userSchema.methods.matchPassword = async function (
    enteredPassword
) {
    return await bcrypt.compare(enteredPassword, this.password);
};

module.exports = mongoose.model('User', userSchema);


File: repositories\auditLog.js
----------------------------------------
// repositories/auditLogRepository.js
const BaseRepository = require('./baseRepository');
const AuditLog = require('../models/auditLog');

class AuditLogRepository extends BaseRepository {
    constructor() {
        console.log("AuditLog Repository created");
        super(AuditLog);
    }

    async getLogs(filter = {}) {
        try {
            const logs = await this.model.find(filter)
                .populate('performedBy', 'username roles')
                .sort({ timestamp: -1 });
                
            return logs;
        } catch (error) {
            throw new Error(`Error fetching audit logs: ${error.message}`);
        }
    }
}

module.exports = AuditLogRepository;


File: repositories\baseRepository.js
----------------------------------------
const CustomError = require("../util/customError");

class BaseRepository {
    constructor(model) {
        this.model = model;
    }

    async create(data) {
        try {
            const doc = await this.model.create(data);
            return doc;
        } catch (error) {
            throw new CustomError(
                `Error creating ${this.model.modelName}: ${error.message}`
            );
        }
    }

    async findAll(filter = {}, options = {}) {
        try {
            const docs = await this.model
                .find(filter)
                .skip(options.skip || 0)
                .limit(options.limit || 100)
                .sort(options.sort || { createdAt: -1 });
            return docs;
        } catch (error) {
            throw new CustomError(
                `Error fetching ${this.model.modelName}s: ${error.message}`
            );
        }
    }

    async findById(id, populate = '') {
        console.log('@!@!@!@! reached bas repository');
        try {
            const doc = await this.model.findById(id).populate(populate);
            return doc;
        } catch (error) {
            throw new CustomError(
                `${this.model.modelName} not found with id ${id}`
            );
        }
    }

    async update(id, data) {
        try {
            const updatedDoc = await this.model.findByIdAndUpdate(
              id,
                data,
                { new: true, runValidators: true }
            );
            return updatedDoc;
        } catch (error) {
            throw new Error(
                `Error updating ${this.model.modelName}: ${error.message}`
            );
        }
    }

    async delete(id) {
        try {
            await this.model.findByIdAndDelete(id);
            return true;
        } catch (error) {
            throw new Error(
                `Error deleting ${this.model.modelName}: ${error.message}`
            );
        }
    }
}

module.exports = BaseRepository;


File: repositories\baseRepositoryWithSoftDelete.js
----------------------------------------
const BaseRepository = require('./baseRepository');

class BaseRepositoryWithSoftDelete extends BaseRepository {
    constructor(model) {
        super(model);
    }

    async softDelete(id) {
        try {
            const doc = await this.model.findById(id);
            if (!doc) throw new Error(`${this.model.modelName} not found with id ${id}`);
            doc.isDeleted = true;
            doc.deletedDate = new Date();
            await doc.save();
            return doc;
        } catch (error) {
            throw new Error(`Error soft deleting ${this.model.modelName}: ${error.message}`);
        }
    }

    async restore(id) {
        try {
            const doc = await this.model.findById(id);
            if (!doc) throw new Error(`${this.model.modelName} not found with id ${id}`);
            doc.isDeleted = false;
            doc.deletedDate = null;
            await doc.save();
            return doc;
        } catch (error) {
            throw new Error(`Error restoring ${this.model.modelName}: ${error.message}`);
        }
    }

    async findAllDeleted() {
        try {
            const docs = await this.model.find({ isDeleted: true });
            return docs;
        } catch (error) {
            throw new Error(`Error fetching deleted ${this.model.modelName}s: ${error.message}`);
        }
    }
}

module.exports = BaseRepositoryWithSoftDelete;


File: repositories\comment.js
----------------------------------------
const Comment = require('../models/comment');
const BaseRepository = require('./baseRepository');

class CommentRepository extends BaseRepository {
    constructor() {
        super(Comment);
    }

    async addAttachments(commentId, attachments) {
        const comment = await this.findById(commentId);
        if (!comment) {
            throw new Error('Comment not found');
        }

        comment.attachments.push(...attachments);
        return await comment.save();
    }
}

module.exports = CommentRepository;


File: repositories\payment.js
----------------------------------------


File: repositories\permission.js
----------------------------------------
const BaseRepository = require('./baseRepositoryWithSoftDelete');
const Permission = require('../models/permission');

class PermissionRepository extends BaseRepository {
    constructor() {
        super(Permission);
    }

    async findByName(name) {
        return await this.model.findOne({name});
    }
}

module.exports = PermissionRepository;

File: repositories\role.js
----------------------------------------
const BaseRepository = require('./baseRepository');
const Role = require('../models/role');

class RoleRepository extends BaseRepository {
    constructor() {
        super(Role);
    }

    async findByName(name) {
        return await this.model.findOne({ name }).populate('permissions');
    }

    async findById(id) {
        console.log("@!@!@!@! Controle reached here");
        return await this.model.findById(id).populate('permissions');
    }

}

module.exports = RoleRepository;


File: repositories\status.js
----------------------------------------
// repositories/statusRepository.js
const BaseRepositoryWithSoftDelete = require('./baseRepositoryWithSoftDelete');
const Status = require('../models/status');
const AuditLog = require('../models/auditLog');

class StatusRepository extends BaseRepositoryWithSoftDelete {
    constructor() {
        console.log("Status Repository created");
        super(Status);
    }

    async getAllStatus(userId) {
        return await this.model.find({}).populate('nextStatuses').populate('prevStatuses');
    }

    async createStatus(statusData, userId) {
        const newStatus = await this.model.create(statusData);

        await AuditLog.create({
            action: 'Status Created',
            performedBy: userId,
            entity: 'Status',
            entityId: newStatus._id,
            changes: { statusData }
        });

        return newStatus;
    }

    async deleteStatus(id, userId) {
        const status = await this.findById(id);
        if (!status) throw new Error('Status not found');

        await this.softDelete(id);

        await AuditLog.create({
            action: 'Status Soft Deleted',
            performedBy: userId,
            entity: 'Status',
            entityId: id
        });

        return status;
    }

    async restoreStatus(id, userId) {
        const status = await this.restore(id);
        if (!status) throw new Error('Status not found');

        await AuditLog.create({
            action: 'Status Restored',
            performedBy: userId,
            entity: 'Status',
            entityId: id
        });

        return status;
    }

    async hardDeleteStatus(id, userId) {
        const status = await this.findById(id);
        if (!status) throw new Error('Status not found');

        await this.delete(id);

        await AuditLog.create({
            action: 'Status Permanently Deleted',
            performedBy: userId,
            entity: 'Status',
            entityId: id
        });

        return status;
    }

    async modifyStatus(id, statusData, userId) {
        const status = await this.update(id, statusData);

        await AuditLog.create({
            action: 'Status Modified',
            performedBy: userId,
            entity: 'Status',
            entityId: id,
            changes: statusData
        });

        return status;
    }

    async addNextStatus(id, nextStatusId, userId) {
        const status = await this.findById(id);
        if (!status) throw new Error('Status not found');

        status.nextStatuses.push(nextStatusId);
        await status.save();

        await AuditLog.create({
            action: 'Next Status Added',
            performedBy: userId,
            entity: 'Status',
            entityId: id,
            changes: { nextStatusId }
        });

        return status;
    }

    async addPrevStatus(id, prevStatusId, userId) {
        const status = await this.findById(id);
        if (!status) throw new Error('Status not found');

        status.prevStatuses.push(prevStatusId);
        await status.save();

        await AuditLog.create({
            action: 'Previous Status Added',
            performedBy: userId,
            entity: 'Status',
            entityId: id,
            changes: { prevStatusId }
        });

        return status;
    }

    async validateTransition(currentStatusId, nextStatusId, userId) {
        const currentStatus = await this.findById(currentStatusId);
        if (!currentStatus) throw new Error('Current status not found');

        if (!currentStatus.nextStatuses.includes(nextStatusId)) {
            throw new Error('Invalid status transition');
        }

        await AuditLog.create({
            action: 'Status Transition Validated',
            performedBy: userId,
            entity: 'StatusTransition',
            entityId: `${currentStatusId}->${nextStatusId}`,
            changes: {}
        });

        return true;
    }

}

module.exports = StatusRepository;


File: repositories\task.js
----------------------------------------
const BaseRepositoryWithSoftDelete = require('./baseRepositoryWithSoftDelete');
const Task = require('../models/task');
const Status = require('../models/status');
const Comment = require('../models/comment');
const AuditLog = require('../models/auditLog');
const User = require('../models/user');

class TaskRepository extends BaseRepositoryWithSoftDelete {
    constructor() {
        console.log("Task Repository created");
        super(Task);
    }

    async getAllTasks(userId) {
        try {
            const tasks = await this.model
                .find({
                    $or: [{ user: userId }, { assignedTo: userId }]
                })
                .populate({
                    path: 'comments',
                    populate: {
                        path: 'createdBy',
                        model: 'User',
                        select: 'username roles'
                    }
                })
                .populate('status');

            if (!tasks || tasks.length === 0)
                throw new Error('Tasks not found or unauthorized');
            return tasks;
        } catch (error) {
            throw new Error(`Error fetching tasks: ${error.message}`);
        }
    }

    async findById(id, userId) {
        const task = await this.model
            .findOne({
                _id: id,
                $or: [{ user: userId }, { assignedTo: userId }]
            })
            .populate({
                path: 'comments',
                populate: {
                    path: 'createdBy',
                    model: 'User',
                    select: 'username roles'
                }
            })
            .populate('status');

        console.log(`@!@!@!@! this is task ${task}`);

        if (!task) throw new Error('Task not found or unauthorized');
        return task;
    }

    async createTask(task, user, assignedTo = null) {
        const openStatus = await Status.findOne({ _id: task.status });
        if (!openStatus) {
            throw new Error('Open status not found');
        }

        const taskToCreate = {
            ...taskData,
            status: status._id,
            user: user._id,
            assignedTo: assignedTo ? assignedTo._id : null,
            createdDate: new Date()
        };

        const newTask = await this.model.create(taskToCreate);

        await AuditLog.create({
            action: 'Task Created',
            performedBy: user._id,
            entity: 'Task',
            entityId: newTask._id,
            changes: taskData
        });

        const populatedTask = await this.model
            .findById(newTask._id)
            .populate('status');

        return populatedTask;
    }

    async updateTask(id, updatedTask, userId) {
        const task = await this.findById(id, userId);

        if (
            task.user.toString() !== userId.toString() &&
            task.assignedTo.toString() !== userId.toString()
        ) {
            throw new Error(
                'Only the creator or assigned user can update this task'
            );
        }

        task.title = updatedTask.title || task.title;
        task.description = updatedTask.description || task.description;
        task.modifiedDate = new Date();

        await AuditLog.create({
            action: 'Task Updated',
            performedBy: userId,
            entity: 'Task',
            entityId: task._id,
            changes: updatedTask
        });

        return await task.save();
    }

    async updateTaskStatus(taskId, statusId, userId) {
        const task = await this.findById(taskId, userId);

        const status = await Status.findById(statusId);
        if (!status) throw new Error('Status not found');

        if (!(await this.validateStatusTransition(task.status, statusId))) {
            throw new Error('Invalid status transition');
        }

        task.status = status._id;
        task.modifiedDate = new Date();

        if (status.statusName.toLowerCase() === 'completed') {
            task.endDate = new Date();
        }

        await AuditLog.create({
            action: 'Task Status Updated',
            performedBy: userId,
            entity: 'Task',
            entityId: task._id,
            changes: { status: status._id }
        });

        return await task.save();
    }

    async validateStatusTransition(currentStatusId, nextStatusId) {
        const currentStatus = await Status.findById(currentStatusId);
        if (!currentStatus) throw new Error('Current status not found');

        const isValidTransition = currentStatus.nextStatuses.includes(
            nextStatusId
        );
        return isValidTransition;
    }

    async assignTask(id, userId, assignedToId) {
        const task = await this.model.findOne({ _id: id, user: userId });
        if (!task) throw new Error('Task not found or unauthorized');

        task.assignedTo = assignedToId;

        await AuditLog.create({
            action: 'Task Assigned',
            performedBy: userId,
            entity: 'Task',
            entityId: task._id,
            changes: { assignedTo: assignedToId }
        });

        return await task.save();
    }

    async deleteTask(id, userId) {
        const task = await this.findById(id, userId);

        await AuditLog.create({
            action: 'Task Deleted',
            performedBy: userId,
            entity: 'Task',
            entityId: task._id
        });

        return await this.model.findByIdAndDelete(id);
    }

    async softDeleteTask(id, userId) {
        const task = await this.findById(id, userId);

        task.isDeleted = true;
        task.deletedDate = new Date();

        await AuditLog.create({
            action: 'Task Soft Deleted',
            performedBy: userId,
            entity: 'Task',
            entityId: task._id
        });

        return await task.save();
    }

    async restoreTask(id, userId) {
        const task = await this.model.findOne({
            _id: id,
            isDeleted: true,
            $or: [{ user: userId }, { assignedTo: userId }]
        });

        if (!task) throw new Error('Task not found or unauthorized');

        task.isDeleted = false;
        task.deletedDate = null;

        await AuditLog.create({
            action: 'Task Restored',
            performedBy: userId,
            entity: 'Task',
            entityId: task._id
        });

        return await task.save();
    }

    async addComment(taskId, userId, commentText) {
        const task = await this.model.findById(taskId);

        if (!task) {
            throw new Error('Task not found');
        }

        if (
            task.user.toString() !== userId.toString() &&
            task.assignedTo.toString() !== userId.toString()
        ) {
            throw new Error(
                'Only the creator or assigned user can comment on this task'
            );
        }

        const newComment = await Comment.create({
            text: commentText,
            createdBy: userId,
            task: taskId
        });

        task.comments.push(newComment._id);
        await task.save();

        await AuditLog.create({
            action: 'Comment Added',
            performedBy: userId,
            entity: 'Comment',
            entityId: newComment._id,
            changes: { text: commentText, taskId }
        });

        return newComment;
    }

    async getTasksByPriority(userId, priority) {
        const validPriorities = ['low', 'medium', 'high'];
        if (!validPriorities.includes(priority)) {
            throw new Error('Invalid priority value');
        }

        return await this.model
            .find({
                $or: [{ user: userId }, { assignedTo: userId }],
                priority: priority
            })
            .populate('status');
    }

    async updateTaskPriority(id, userId, priority) {
        const task = await this.findById(id, userId);

        const validPriorities = ['low', 'medium', 'high'];
        if (!validPriorities.includes(priority)) {
            throw new Error('Invalid priority value');
        }

        task.priority = priority;
        task.modifiedDate = new Date();

        await AuditLog.create({
            action: 'Task Priority Updated',
            performedBy: userId,
            entity: 'Task',
            entityId: task._id,
            changes: { priority: priority }
        });

        return await task.save();
    }

    async getTasksAssignedTo(userId) {
        return await this.model
            .find({
                assignedTo: userId
            })
            .populate('status');
    }

    async getTasksCreatedBy(userId) {
        return await this.model
            .find({
                user: userId
            })
            .populate('status');
    }

    async getDeletedTasks(userId) {
        return await this.model
            .find({
                isDeleted: true,
                $or: [{ user: userId }, { assignedTo: userId }]
            })
            .populate('status');
    }

    async getTasksByStatus(userId, statusId) {
        return await this.model
            .find({
                $or: [{ user: userId }, { assignedTo: userId }],
                status: statusId
            })
            .populate('status');
    }

    async getTasksByDateRange(userId, startDate, endDate) {
        const query = {
            $or: [{ user: userId }, { assignedTo: userId }],
            createdDate: { $gte: startDate, $lte: endDate }
        };

        return await this.model.find(query).populate('status');
    }

    async searchTasks(userId, searchTerm) {
        return await this.model
            .find({
                $or: [{ user: userId }, { assignedTo: userId }],
                $or: [
                    { title: new RegExp(searchTerm, 'i') },
                    { description: new RegExp(searchTerm, 'i') }
                ]
            })
            .populate('status');
    }

    async getOverdueTasks(userId) {
        const today = new Date();

        const completedStatus = await Status.findOne({
            statusName: 'completed'
        });

        if (!completedStatus) throw new Error('Completed status not found');

        return await this.model
            .find({
                $or: [{ user: userId }, { assignedTo: userId }],
                endDate: { $lt: today },
                status: { $ne: completedStatus._id }
            })
            .populate('status');
    }

    async getTasksDueToday(userId) {
        const startOfDay = new Date();
        startOfDay.setHours(0, 0, 0, 0);

        const endOfDay = new Date();
        endOfDay.setHours(23, 59, 59, 999);

        return await this.model
            .find({
                $or: [{ user: userId }, { assignedTo: userId }],
                endDate: { $gte: startOfDay, $lte: endOfDay }
            })
            .populate('status');
    }

    async unassignTask(id, userId) {
        const task = await this.model.findOne({ _id: id, user: userId });
        if (!task) throw new Error('Task not found or unauthorized');

        task.assignedTo = null;

        await AuditLog.create({
            action: 'Task Unassigned',
            performedBy: userId,
            entity: 'Task',
            entityId: task._id
        });

        return await task.save();
    }

    async updateTaskEndDate(id, userId, endDate) {
        const task = await this.findById(id, userId);

        task.endDate = endDate;
        task.modifiedDate = new Date();

        await AuditLog.create({
            action: 'Task End Date Updated',
            performedBy: userId,
            entity: 'Task',
            entityId: task._id,
            changes: { endDate: endDate }
        });

        return await task.save();
    }
}

module.exports = TaskRepository;


File: repositories\user.js
----------------------------------------
const BaseRepository = require('./baseRepository');
const User = require('../models/user');
const AuditLog = require('../models/auditLog');
const payment = require('../models/payment');
const CustomError = require('../util/customError');

class UserRepository extends BaseRepository {
    constructor() {
        console.log('User Repository created');
        // this.Payment = Payment;
        super(User);
    }

    async findByUsername(username) {
        try {
            return await this.model.findOne({ username });
        } catch (error) {
            throw new Error(`Error finding user by username: ${error.message}`);
        }
    }

    async validateUser(username, password) {
        const user = await this.findByUsername(username);
        if (user && await user.matchPassword(password)) {
            return user;
        }
        return null;
    }

    async createUser(userData) {
        try {        
            console.log("@!@!@!@!@!@! userData",userData);
            const newUser = await this.create(userData);
            await AuditLog.create({
                action: 'User Registered',
                performedBy: newUser._id,
                entity: 'User',
                entityId: newUser._id,
                changes: { username: newUser.username, roles: newUser.roles }
            });
            return newUser;
        }
        catch (e) {
            throw new CustomError("Failed to create the user");
        }
    }

    async getAllAdmins() {
        return await this.model.find({ roles: 'admin' }).select('username roles');
    }

}

module.exports = UserRepository;


File: routes\comment.js
----------------------------------------
const express = require('express');
const CommentController = require('../controllers/comment');
const { protect } = require('../middleware/auth');
const { uploadMultiple } = require('../middleware/upload');

const router = express.Router();
const commentController = new CommentController();

router.post(
    '/tasks/:taskId/comments',
    protect,
    uploadMultiple,
    commentController.addComment
);

router.post(
    '/comments/:commentId/attachments',
    protect,
    uploadMultiple,
    commentController.addAttachmentsToComment
);

router.get(
    '/comments/:commentId/attachments/:attachmentId/download',
    protect,
    commentController.downloadAttachment
);

router.delete(
    '/comments/:commentId/attachments/:attachmentId',
    protect,
    commentController.deleteAttachment
);

module.exports = router;


File: routes\role.js
----------------------------------------
const express = require('express');
const { roleController } = require('../bootstrap');
const { protect, authorize } = require('../middleware/auth');

const router = express.Router();

router.post('/', roleController.createRole);
router.get('/', protect, roleController.getAllRoles);
router.get('/:id', protect, roleController.getRoleById);

module.exports = router;


File: routes\status.js
----------------------------------------
const express = require('express');
const { statusController } = require('../bootstrap');
const { protect } = require('../middleware/auth');
const router = express.Router();

console.log('Status router created in the routes');

router.get('/', protect, statusController.getAllStatus);
router.get('/deleted', protect, statusController.getDeletedStatuses);
router.get('/:id', protect, statusController.findStatusById);
router.post('/', protect, statusController.createStatus);
router.delete('/:id', protect, statusController.deleteStatus);
router.post('/:id/restore', protect, statusController.restoreStatus);
router.delete('/:id/hard-delete', protect, statusController.hardDeleteStatus);
router.put('/:id', protect, statusController.modifyStatus);
router.post('/:id/next-status', protect, statusController.addNextStatus);
router.post('/:id/prev-status', protect, statusController.addPrevStatus);
router.get('/validate-transition/:currentStatusId/:nextStatusId', protect, statusController.validateTransition);

module.exports = router;


File: routes\task.js
----------------------------------------
const express = require('express');
const { taskController } = require('../bootstrap');
const { protect, authorize } = require('../middleware/auth');
const router = express.Router();

console.log('Task router created');

router.get('/', protect, authorize(['VIEW_TASKS']), taskController.getAllTasks);
router.get('/assigned', protect, taskController.getTasksAssignedTo);
router.get('/created', protect, taskController.getTasksCreatedBy);
router.get('/deleted', protect, taskController.getDeletedTasks);
router.get('/overdue', protect, taskController.getOverdueTasks);
router.get('/due-today', protect, taskController.getTasksDueToday);
router.get('/priority/:priority', protect, taskController.getTasksByPriority);
router.get('/status/:statusId', protect, taskController.getTasksByStatus);
router.get('/search/:searchTerm', protect, taskController.searchTasks);
router.get('/:id', protect, taskController.getTaskById);

router.post('/', protect, authorize(['CREATE_TASK']), taskController.createTask);
router.post('/:id/assign', protect, taskController.assignTask);
router.post('/:id/unassign', protect, taskController.unassignTask);
router.post('/:id/restore', protect, taskController.restoreTask);
router.post('/date-range', protect, taskController.getTasksByDateRange);

router.put('/:id', protect, authorize(['UPDATE_TASK']), taskController.updateTask);
router.put('/:id/end-date', protect, taskController.updateTaskEndDate);
router.put('/:id/priority', protect, taskController.updateTaskPriority);
router.put('/:taskId/status/:statusId', protect, taskController.updateTaskStatus);

router.delete('/:id', protect, authorize(['DELETE_TASK']), taskController.deleteTask);
router.delete('/:id/soft-delete', protect, taskController.softDeleteTask);

module.exports = router;


File: routes\user.js
----------------------------------------
const express = require('express');
const { userController } = require('../bootstrap');
const { protect } = require('../middleware/auth');
const limiter = require('../middleware/rateLimit');

const router = express.Router();
console.log('User router created');

// Register a new user (public)
router.post('/register', limiter, userController.registerUser);

// Login user (public)
router.post('/login', limiter, userController.loginUser);

router.get('/:id', protect, userController.getUserById);
router.get('/', protect, userController.getAllUsers);
router.post('/assign-role', protect, userController.assignRole);

module.exports = router;


File: script.js
----------------------------------------
const fs = require('fs');
const path = require('path');

var num = 0;

// Directory to start scanning
const startDir = './'; // Change this to your starting directory if needed
const outputFilePath = 'output.txt';

// Function to get all .js files from a directory recursively
function getAllJsFiles(dir, fileList = []) {
  const files = fs.readdirSync(dir);

  files.forEach((file) => {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);

    if (stat.isDirectory() && file !== 'node_modules') {
      getAllJsFiles(filePath, fileList);
    } else if (path.extname(file) === '.js') {
      fileList.push(filePath);
    }
  });

  return fileList;
}

// Function to write all .js file names, paths, and content to a .txt file
function writeJsFilesToTxt(jsFiles, outputFile) {
  const writeStream = fs.createWriteStream(outputFile);

  jsFiles.forEach((filePath) => {
    const content = fs.readFileSync(filePath, 'utf8');
    writeStream.write(`File: ${filePath}\n`);
    writeStream.write('----------------------------------------\n');
    writeStream.write(`${content}\n\n`);
    num  = num +1;
  });


  writeStream.end();
}

// Main process
try {
  const jsFiles = getAllJsFiles(startDir);
  writeJsFilesToTxt(jsFiles, outputFilePath);
  console.log(`All JavaScript files have been written to ${outputFilePath}`);
  console.log(num);
} catch (err) {
  console.error('Error:', err);
}

File: seed.js
----------------------------------------
const Permission = require('./models/permission');
const Role = require('./models/role');

const seedPermissionsAndRoles = async () => {
    // Define permissions
    const permissions = [
        { name: 'VIEW_TASKS', description: 'View all tasks' },
        { name: 'CREATE_TASK', description: 'Create new task' },
        { name: 'UPDATE_TASK', description: 'Update existing task' },
        { name: 'DELETE_TASK', description: 'Delete task' }
    ];

    // Seed permissions
    for (const permissionData of permissions) {
        const existingPermission = await Permission.findOne({ name: permissionData.name });
        if (!existingPermission) {
            await Permission.create(permissionData);
        }
    }

    // Define roles and map permissions to roles
    const roles = [
        { name: 'admin', permissions: ['VIEW_TASKS', 'CREATE_TASK', 'UPDATE_TASK', 'DELETE_TASK'] },
        { name: 'user', permissions: ['VIEW_TASKS'] }
    ];

    // Seed roles
    for (const roleData of roles) {
        const existingRole = await Role.findOne({ name: roleData.name });
        if (!existingRole) {
            const rolePermissions = await Permission.find({ name: { $in: roleData.permissions } });
            const newRole = new Role({ name: roleData.name, permissions: rolePermissions.map(p => p._id) });
            await newRole.save();
        }
    }



    console.log('Permissions and roles seeded successfully.');
};


module.exports = seedPermissionsAndRoles;


File: services\auditLog.js
----------------------------------------
const BaseService = require('./baseService');

class AuditLogService extends BaseService {
    constructor(repository) {
        super(repository);
    }

    async getAuditLogs(filter = {}, options = {}) {
        return await this.repository.getLogs(filter, options);
    }
}

module.exports = AuditLogService;


File: services\baseService.js
----------------------------------------
class BaseService {
    constructor(repository) {
        this.repository = repository;
    }

    async create(data) {
        return await this.repository.create(data);
    }

    async findAll(filter = {}, options = {}) {
        return await this.repository.findAll(filter, options);
    }

    async findById(id, populate = '') {
        return await this.repository.findById(id, populate);
    }

    async update(id, data) {
        return await this.repository.update(id, data);
    }

    async delete(id) {
        return await this.repository.delete(id);
    }
}

module.exports = BaseService;


File: services\comment.js
----------------------------------------
const BaseService = require('./baseService');
const fs = require('fs').promises;

class CommentService extends BaseService {
    constructor(repository) {
        super(repository);
    }

    async addAttachmentToComment(commentId, attachments) {
        return await this.repository.addAttachments(commentId, attachments);
    }

    async deleteAttachment(commentId, attachmentId) {
        const comment = await this.repository.findById(commentId);
        if (!comment) {
            throw new Error('Comment not found');
        }

        const attachment = comment.attachments.id(attachmentId);
        if (!attachment) {
            throw new Error('Attachment not found');
        }

        await fs.unlink(attachment.filepath).catch(err => {
            console.error('Error deleting file:', err);
        });

        attachment.remove();
        return await comment.save();
    }
}

module.exports = CommentService;


File: services\email.js
----------------------------------------
require('dotenv').config();
const nodemailer = require('nodemailer');

const transporter = nodemailer.createTransport({
    service: process.env.EMAIL_SERVICE,
    auth: {
        user: process.env.EMAIL_USER,
        pass: process.env.EMAIL_PASS
    }
});

async function sendEmail(to, subject, text) {
    const mailOptions = {
        from: process.env.EMAIL_USER,
        to,
        subject,
        text
    };

    try {
        await transporter.sendMail(mailOptions);
        console.log(`Email sent to ${to}`);
    } catch (error) {
        console.error('Error sending email:', error);
    }
}

module.exports = {
    sendEmail
};


File: services\role.js
----------------------------------------
const BaseService = require('./baseService');
const CustomError = require('../util/customError');

class RoleService extends BaseService {
    constructor(repository) {
        super(repository);
    }

    async createRole(roleData) {
        const existingRole = await this.repository.findByName(roleData.name);
        console.log('Creating role with data:', roleData);
        
        if (existingRole) {
            throw new CustomError('Role already exists');
        }
        return await this.repository.create(roleData);
    }

    async getAllRoles() {
        return await this.repository.findAll();
    }

    async getRoleByName(roleName) {
        return await this.repository.findByName(roleName);
    }

    async getRoleById(id) {
        return await this.repository.findById(id);
    }
}

module.exports = RoleService;


File: services\status.js
----------------------------------------
const BaseService = require('./baseService');

class StatusService extends BaseService {
    constructor(repository, auditLogRepository) {
        super(repository);
        this.auditLogRepository = auditLogRepository;
    }

    async getAllStatus(user) {
        return await this.repository.getAllStatus(user._id);
    }

    async getDeletedStatuses(user) {
        return await this.repository.findAllDeleted();
    }

    async createStatus(statusData, user) {
        return await this.repository.createStatus(statusData, user._id);
    }

    async deleteStatus(id, user) {
        return await this.repository.deleteStatus(id, user._id);
    }

    async restoreStatus(id, user) {
        return await this.repository.restoreStatus(id, user._id);
    }

    async hardDeleteStatus(id, user) {
        return await this.repository.hardDeleteStatus(id, user._id);
    }

    async modifyStatus(id, statusData, user) {
        return await this.repository.modifyStatus(id, statusData, user._id);
    }

    async addNextStatus(id, nextStatusId, user) {
        return await this.repository.addNextStatus(id, nextStatusId, user._id);
    }

    async addPrevStatus(id, prevStatusId, user) {
        return await this.repository.addPrevStatus(id, prevStatusId, user._id);
    }

    async validateTransition(currentStatusId, nextStatusId, user) {
        return await this.repository.validateTransition(currentStatusId, nextStatusId, user._id);
    }
}

module.exports = StatusService;


File: services\task.js
----------------------------------------
const BaseService = require('./baseService');
const { sendEmail } = require('./email');
const UserRepository = require('../repositories/user');
const Status = require('../models/status');

class TaskService extends BaseService {
    constructor(repository, commentRepository) {
        console.log('Task Service created');
        super(repository);
        this.commentRepository = commentRepository;
        this.userRepository = new UserRepository();
    }

    async getAllTasks(user) {
        return await this.repository.getAllTasks(user._id);
    }

    async findById(id, user) {
        return await this.repository.findById(id, user._id);
    }

    async createTask(taskData, user, assignedToId = null) {
        let assignedTo = null;
        if (assignedToId) {
            assignedTo = await this.userRepository.findById(assignedToId);
            if (!assignedTo) {
                throw new Error('Assigned user not found');
            }
        }

        const newTask = await this.repository.createTask(
            taskData,
            user,
            assignedTo
        );

        if (assignedTo) {
            await sendEmail(
                assignedTo.email,
                'New Task Assigned',
                `You have been assigned a new task: ${taskData.title}`
            );
        }

        return newTask;
    }

    async updateTask(id, task, user) {
        return await this.repository.updateTask(id, task, user._id);
    }

    async updateTaskStatus(taskId, statusId, user) {
        const updatedTask = await this.repository.updateTaskStatus(
            taskId,
            statusId,
            user._id
        );

        const taskOwner = await this.userRepository.findById(updatedTask.user);
        if (taskOwner) {
            const status = await Status.findById(statusId);
            await sendEmail(
                taskOwner.email,
                'Task Status Updated',
                `The status of your task "${updatedTask.title}" has been updated to "${status.statusName}".`
            );
        }

        return updatedTask;
    }

    async deleteTask(id, user) {
        return await this.repository.deleteTask(id, user._id);
    }

    async assignTask(id, userId, assignedToId) {
        const updatedTask = await this.repository.assignTask(
            id,
            userId,
            assignedToId
        );

        const assignedToUser = await this.userRepository.findById(
            assignedToId
        );
        if (assignedToUser) {
            await sendEmail(
                assignedToUser.email,
                'Task Assigned',
                `You have been assigned a task: ${updatedTask.title}`
            );
        }

        return updatedTask;
    }

    async addComment(taskId, user, commentText) {
        return await this.repository.addComment(taskId, user._id, commentText);
    }

    async getTasksByPriority(user, priority) {
        return await this.repository.getTasksByPriority(user._id, priority);
    }

    async updateTaskPriority(id, user, priority) {
        return await this.repository.updateTaskPriority(id, user._id, priority);
    }

    async getTasksAssignedTo(user) {
        return await this.repository.getTasksAssignedTo(user._id);
    }

    async getTasksCreatedBy(user) {
        return await this.repository.getTasksCreatedBy(user._id);
    }

    async softDeleteTask(id, user) {
        return await this.repository.softDeleteTask(id, user._id);
    }

    async restoreTask(id, user) {
        return await this.repository.restoreTask(id, user._id);
    }

    async getDeletedTasks(user) {
        return await this.repository.getDeletedTasks(user._id);
    }

    async getTasksByStatus(user, statusId) {
        return await this.repository.getTasksByStatus(user._id, statusId);
    }

    async getTasksByDateRange(user, startDate, endDate) {
        return await this.repository.getTasksByDateRange(
            user._id,
            startDate,
            endDate
        );
    }

    async searchTasks(user, searchTerm) {
        return await this.repository.searchTasks(user._id, searchTerm);
    }

    async getOverdueTasks(user) {
        return await this.repository.getOverdueTasks(user._id);
    }

    async getTasksDueToday(user) {
        return await this.repository.getTasksDueToday(user._id);
    }

    async unassignTask(id, user) {
        return await this.repository.unassignTask(id, user._id);
    }

    async updateTaskEndDate(id, user, endDate) {
        return await this.repository.updateTaskEndDate(
            id,
            user._id,
            endDate
        );
    }
}

module.exports = TaskService;


File: services\user.js
----------------------------------------
const BaseService = require('./baseService');
const { generateToken } = require('../util/jwt');
const CustomError = require('../util/customError');

class UserService extends BaseService {
    constructor(userRepository, roleRepository) {
        super(userRepository);
        this.roleRepository = roleRepository; // Injecting roleRepository here
    }

    async registerUser(userData) {
        const existingUser = await this.repository.findByUsername(userData.username);
        if (existingUser) {
            throw new CustomError('User already exists');
        }

        if (!userData.roles) {
            const role = await this.roleRepository.findByName('user');
            if (!role) {
                throw new CustomError('user role not found', 500);
            }
            userData.roles = role._id; 
        }

        const newUser = await this.repository.createUser(userData);

        const token = await generateToken(newUser._id);

        return {
            _id: newUser._id,
            username: newUser.username,
            email: newUser.email,
            roles: newUser.roles,
            token: 'Bearer ' + token
        };
    }

    async loginUser(username, password) {
        const user = await this.repository.validateUser(username, password);
        if (!user) {
            throw new CustomError('Invalid username or password');
        }
    
        const foundUser = await this.repository.model
            .findById(user._id)
            .populate('roles'); 
    
        const token = await generateToken(foundUser._id);
    
        return {
            _id: foundUser._id,
            username: foundUser.username,
            email: foundUser.email,
            roles: foundUser.roles, 
            token: 'Bearer ' + token
        };
    }
    

    async getUserById(id) {
        const user = await this.repository.findById(id).populate('roles');
        if (!user) {
            throw new CustomError('User not found');
        }
        return user;
    }

    async getAllUsers() {
        return await this.repository.findAll({}, { populate: 'roles' });
    }

    async assignRole(userId, roleId) {
        try {
            
            const user = await this.repository.findById(userId);
            if (!user) {
                throw new CustomError('User not found');
            }
    
            const role = await this.roleRepository.findById(roleId);
            if (!role) {
                throw new CustomError('Role not found');
            }
    
            if (!user.roles.includes(roleId)) {
                user.roles.push(roleId);
    
                try {
                    await user.save();
                    console.log('@!@!@!@! Roles assigning completed');
                } catch (error) {
                    console.error('Error while saving user:', error);
                    throw new CustomError('Error while saving user role');
                }
            } else {
                console.log('@!@!@!@! Role already assigned to the user');
            }
    
            const savedUser =  await this.repository.findById(userId);
            return await savedUser.populate('roles');
        } catch (error) {
            console.error('Error in assignRole function:', error);
            throw new CustomError('Internal Server Error');
        }
    }
}

module.exports = UserService;


File: util\customError.js
----------------------------------------
class CustomError extends Error {
    constructor(message, statusCode) {
        if (typeof message !== 'string') {
            message = JSON.stringify(message);
        }
        super(message); 
        this.statusCode = statusCode;
        this.name = 'CustomError'; 
    }

    static handleError(err, res) {
        const status = err.statusCode || 500;
        const responseMessage = err.message || 'An error occurred';
        res.status(status).json({
            success: false,
            message: responseMessage,
        });
    }
}

module.exports = CustomError; 

File: util\jwt.js
----------------------------------------
const jwt = require('jsonwebtoken');

const generateToken = async userId => {
    const token = await jwt.sign({ id: userId }, process.env.JWT_SECRET, {
        expiresIn: '60d'
    });
    return token;
};

module.exports = { generateToken };


