File: bootstrap.js
----------------------------------------
const TaskRepository = require('./repositories/task');
const CommentRepository = require('./repositories/comment');
const TaskService = require('./services/task');
const TaskController = require('./controllers/task');
const StatusRepository = require('./repositories/status');
const StatusService = require('./services/status');
const StatusController = require('./controllers/status');
const UserRepository = require('./repositories/user');
const UserService = require('./services/user');
const UserController = require('./controllers/user');
const RoleRepository = require('./repositories/role');
const RoleService = require('./services/role');
const RoleController = require('./controllers/role');
const AuditLogRepository = require('./repositories/auditLog');
const AuditLogService = require('./services/auditLog');
const CommentController = require('./controllers/comment');
const CommentService = require('./services/comment');
const PaymentRepository = require('./repositories/payment');
const PaymentController = require('./controllers/payment');
const PaymentService = require('./services/payment');

const taskRepository = new TaskRepository();
const commentRepository = new CommentRepository();
const statusRepository = new StatusRepository();
const userRepository = new UserRepository();
const roleRepository = new RoleRepository();
const auditLogRepository = new AuditLogRepository();
const paymentRepository = new PaymentRepository();

const roleService = new RoleService(roleRepository);
const userService = new UserService(userRepository, roleService);
const auditLogService = new AuditLogService(auditLogRepository);
const statusService = new StatusService(statusRepository, auditLogService);
const commentService = new CommentService(commentRepository);
const paymentService = new PaymentService(paymentRepository,userService);
const taskService = new TaskService(
    taskRepository,
    commentService,
    userService,
    statusService,
    auditLogService
);

const taskController = new TaskController(taskService);
const statusController = new StatusController(statusService);
const userController = new UserController(userService);
const roleController = new RoleController(roleService);
const commentController = new CommentController(commentService);
const paymentController = new PaymentController(paymentService);

module.exports = {
    taskController,
    statusController,
    userController,
    roleController,
    commentController,
    paymentController
};


File: config\db.js
----------------------------------------
// config/db.js
const mongoose = require('mongoose');
const dotenv = require('dotenv');

dotenv.config();
const uri = process.env.DBURI;

if (!uri) {
  throw new Error(' Make sure DBURI is not defined.');
}

mongoose
  .connect(uri, {
    useNewUrlParser: true,
    useUnifiedTopology: true
  })
  .then(() => console.log('MongoDB connected'))
  .catch(err =>
    console.error('Error connecting to MongoDB:', err)
  );


File: controllers\comment.js
----------------------------------------
const asyncHandler = require('../middleware/asynchandler');
const CommentService = require('../services/comment');
const CommentRepository = require('../repositories/comment');
const path = require('path');
const fs = require('fs');

class CommentController {
    constructor() {
        const commentRepository = new CommentRepository();
        this.commentService = new CommentService(commentRepository);
    }

    addComment = asyncHandler(async (req, res) => {
        const { taskId } = req.params;
        const { text } = req.body;

        const attachments = req.files
            ? req.files.map(file => ({
                  filename: file.filename,
                  filepath: file.path
              }))
            : [];

        const newComment = await this.commentService.create({
            text,
            createdBy: req.user._id,
            task: taskId,
            attachments
        });

        res.status(201).json(newComment);
    });

    addAttachmentsToComment = asyncHandler(async (req, res) => {
        const { commentId } = req.params;

        const attachments = req.files.map(file => ({
            filename: file.filename,
            filepath: file.path
        }));

        const updatedComment = await this.commentService.addAttachmentToComment(
            commentId,
            attachments
        );

        res.status(200).json(updatedComment);
    });

    downloadAttachment = asyncHandler(async (req, res) => {
        const { commentId, attachmentId } = req.params;
        const comment = await this.commentService.findById(commentId);

        if (!comment) {
            return res.status(404).json({ message: 'Comment not found' });
        }

        const attachment = comment.attachments.id(attachmentId);
        if (!attachment) {
            return res.status(404).json({ message: 'Attachment not found' });
        }

        const filePath = path.resolve(attachment.filepath);
        res.download(filePath, attachment.filename);
    });

    deleteAttachment = asyncHandler(async (req, res) => {
        const { commentId, attachmentId } = req.params;
        const updatedComment = await this.commentService.deleteAttachment(
            commentId,
            attachmentId
        );

        res.status(200).json(updatedComment);
    });
}

module.exports = CommentController;


File: controllers\payment.js
----------------------------------------
const asyncHandler = require('../middleware/asynchandler');

class PaymentController {
    constructor(paymentService) {
        this.paymentService = paymentService;
    }

    getUserPayments = asyncHandler(async (req, res) => {
        const payments = await this.paymentService.getUserPayments(req.user._id);
        res.status(200).json(payments);
    });

    createPayment = asyncHandler(async (req, res) => {
        const paymentData = req.body;
        const payment = await this.paymentService.createPayment(paymentData, req.user._id);
        res.status(201).json(payment);
    });


}

module.exports = PaymentController;

File: controllers\role.js
----------------------------------------
const asyncHandler = require('../middleware/asynchandler');
const CustomError = require('../util/customError');

class RoleController {
    constructor(roleService) {
        this.roleService = roleService;
    }

    createRole = asyncHandler(async (req, res,next) => {
        const {role} = req.body;
        if(role == "president") {
            next(new CustomError("Cannot create this role",400));
        }
        console.log(req.body);
        let roles = await this.roleService.createRole(req.body);
        res.status(201).json(roles);
    });

    getAllRoles = asyncHandler(async (req, res) => {
        const roles = await this.roleService.getAllRoles();
        res.status(200).json(roles);
    });

    getRoleById = asyncHandler(async (req, res) => {
        const role = await this.roleService.getRoleById(req.params.id);
        res.status(200).json(role);
    });
}

module.exports = RoleController;


File: controllers\status.js
----------------------------------------
const asyncHandler = require('../middleware/asynchandler');

class StatusController {
    constructor(service) {
        this.service = service;
    }

    getAllStatus = asyncHandler(async (req, res) => {
        const statuses = await this.service.getAllStatus(req.user);
        res.status(200).json(statuses);
    });

    getDeletedStatuses = asyncHandler(async (req, res) => {
        const statuses = await this.service.getDeletedStatuses(req.user);
        res.status(200).json(statuses);
    });

    findStatusById = asyncHandler(async (req, res) => {
        const id = req.params.id;
        const status = await this.service.findById(id, req.user);
        res.status(200).json(status);
    });

    createStatus = asyncHandler(async (req, res) => {
        const status = await this.service.createStatus(
            req.body,
            req.user
        );
        res.status(201).json(status);
    });

    deleteStatus = asyncHandler(async (req, res) => {
        const id = req.params.id;
        await this.service.deleteStatus(id, req.user);
        res.status(200).json({
            message: 'Status soft deleted successfully'
        });
    });

    restoreStatus = asyncHandler(async (req, res) => {
        const id = req.params.id;
        const restoredStatus = await this.service.restoreStatus(
            id,
            req.user
        );
        res.status(200).json({
            message: 'Status restored successfully',
            restoredStatus
        });
    });

    hardDeleteStatus = asyncHandler(async (req, res) => {
        const id = req.params.id;
        await this.service.hardDeleteStatus(id, req.user);
        res.status(200).json({
            message: 'Status permanently deleted successfully'
        });
    });

    modifyStatus = asyncHandler(async (req, res) => {
        const id = req.params.id;
        const bodyToModify = req.body;
        const modifiedStatus = await this.service.modifyStatus(
            id,
            bodyToModify,
            req.user
        );
        res.status(200).json(modifiedStatus);
    });

    addNextStatus = asyncHandler(async (req, res) => {
        const { id } = req.params;
        const { nextStatusId } = req.body;
        const status = await this.service.addNextStatus(
            id,
            nextStatusId,
            req.user
        );
        res.status(200).json(status);
    });

    addPrevStatus = asyncHandler(async (req, res) => {
        const { id } = req.params;
        const { prevStatusId } = req.body;
        const status = await this.service.addPrevStatus(
            id,
            prevStatusId,
            req.user
        );
        res.status(200).json(status);
    });

    validateTransition = asyncHandler(async (req, res) => {
        const { currentStatusId, nextStatusId } = req.params;
        await this.service.validateTransition(
            currentStatusId,
            nextStatusId,
            req.user
        );
        res.status(200).json({ message: 'Status transition is valid' });
    });
}

module.exports = StatusController;


File: controllers\task.js
----------------------------------------
const asyncHandler = require('../middleware/asynchandler');

class TaskController {
    constructor(taskService) {
        this.taskService = taskService;
    }

    getAllTasks = asyncHandler(async (req, res) => {
        const tasks = await this.taskService.getAllTasks(req.user);
        res.status(200).json(tasks);
    });

    getTaskById = asyncHandler(async (req, res) => {
        const task = await this.taskService.findById(req.params.id, req.user);
        res.status(200).json(task);
    });

    createTask = asyncHandler(async (req, res) => {
        const { assignedTo, ...taskData } = req.body;
        const createdTask = await this.taskService.createTask(taskData, req.user, assignedTo);
        res.status(201).json(createdTask);
    });

    updateTask = asyncHandler(async (req, res) => {
        const updatedTask = await this.taskService.updateTask(req.params.id, req.body, req.user);
        res.status(200).json(updatedTask);
    });

    updateTaskStatus = asyncHandler(async (req, res) => {
        const updatedTask = await this.taskService.updateTaskStatus(req.params.taskId, req.params.statusId, req.user);
        res.status(200).json(updatedTask);
    });

    deleteTask = asyncHandler(async (req, res) => {
        const deletedTask = await this.taskService.deleteTask(req.params.id, req.user);
        res.status(200).json({
            message: 'Task deleted successfully',
            deletedTask
        });
    });

    assignTask = asyncHandler(async (req, res) => {
        const { assignedToId } = req.body;
        const updatedTask = await this.taskService.assignTask(req.params.id, req.user._id, assignedToId);
        res.status(200).json(updatedTask);
    });

    softDeleteTask = asyncHandler(async (req, res) => {
        const deletedTask = await this.taskService.softDeleteTask(req.params.id, req.user);
        res.status(200).json({
            message: 'Task soft deleted successfully',
            deletedTask
        });
    });

    restoreTask = asyncHandler(async (req, res) => {
        const restoredTask = await this.taskService.restoreTask(req.params.id, req.user);
        res.status(200).json({
            message: 'Task restored successfully',
            restoredTask
        });
    });

    getDeletedTasks = asyncHandler(async (req, res) => {
        const tasks = await this.taskService.getDeletedTasks(req.user);
        res.status(200).json(tasks);
    });

    getTasksByPriority = asyncHandler(async (req, res) => {
        const { priority } = req.params;
        const tasks = await this.taskService.getTasksByPriority(req.user, priority);
        res.status(200).json(tasks);
    });

    updateTaskPriority = asyncHandler(async (req, res) => {
        const { priority } = req.body;
        const updatedTask = await this.taskService.updateTaskPriority(req.params.id, req.user, priority);
        res.status(200).json(updatedTask);
    });

    getTasksAssignedTo = asyncHandler(async (req, res) => {
        const tasks = await this.taskService.getTasksAssignedTo(req.user);
        res.status(200).json(tasks);
    });

    getTasksCreatedBy = asyncHandler(async (req, res) => {
        const tasks = await this.taskService.getTasksCreatedBy(req.user);
        res.status(200).json(tasks);
    });

    getOverdueTasks = asyncHandler(async (req, res) => {
        const tasks = await this.taskService.getOverdueTasks(req.user);
        res.status(200).json(tasks);
    });

    getTasksDueToday = asyncHandler(async (req, res) => {
        const tasks = await this.taskService.getTasksDueToday(req.user);
        res.status(200).json(tasks);
    });

    searchTasks = asyncHandler(async (req, res) => {
        const { searchTerm } = req.params;
        const tasks = await this.taskService.searchTasks(req.user, searchTerm);
        res.status(200).json(tasks);
    });

    unassignTask = asyncHandler(async (req, res) => {
        const updatedTask = await this.taskService.unassignTask(req.params.id, req.user);
        res.status(200).json(updatedTask);
    });

    updateTaskEndDate = asyncHandler(async (req, res) => {
        const { endDate } = req.body;
        const updatedTask = await this.taskService.updateTaskEndDate(req.params.id, req.user, endDate);
        res.status(200).json(updatedTask);
    });
}

module.exports = TaskController;


File: controllers\user.js
----------------------------------------
const asyncHandler = require('../middleware/asynchandler');
const CustomError = require('../util/customError');

class UserController {
    constructor(userService) {
        this.userService = userService;
        console.log('User Controller created');
    }

    registerUser = asyncHandler(async (req, res) => {
        const { username, email, password,roles } = req.body;
        console.log(`@!@!@!@!@! USerController ${username}`);

        const user = await this.userService.registerUser({
            username,
            email,
            password,
            roles
        });

        console.log(`@!@!@!@! registerUSer Called`)
        res.status(201).json(user);
    });

    loginUser = asyncHandler(async (req, res) => {
        const { username, password } = req.body;
        const user = await this.userService.loginUser(
            username,
            password
        );
        res.status(200).json(user);
    });

    getUserById = asyncHandler(async (req, res) => {
        const userId = req.params.id;
        const user = await this.userService.getUserById(userId);
        res.status(200).json(user);
    });

    getAllUsers = asyncHandler(async (req, res) => {
        const users = await this.userService.getAllUsers();
        res.status(200).json(users);
    });

    assignRole = asyncHandler(async (req, res) => {
        const { userId, roles } = req.body;
        console.log("@!@!@!@! userController",userId ,roles)
        const updatedUser = await this.userService.assignRole(userId, roles);
        res.status(200).json(updatedUser);
    });
}

module.exports = UserController;


File: index.js
----------------------------------------
const express = require('express');
const dotenv = require('dotenv');
const errorHandler = require('./middleware/errorHandler')

const CustomError = require('./util/customError');
const taskRoutes = require('./routes/task');
const statusRoutes = require('./routes/status');
const userRoutes = require('./routes/user');
const roleRoutes = require('./routes/role');
// const commentRoutes = require('./routes/comment');
const paymentRoutes = require('./routes/payment');

const seedPermissionsAndRoles = require('./seed');

dotenv.config();

const app = express();
app.use(express.json());


// Mount routes
app.use('/api/tasks', taskRoutes);
app.use('/api/status', statusRoutes);
app.use('/api/users', userRoutes);
app.use('/api/roles', roleRoutes);
// app.use('/api', commentRoutes);
app.use('/api/payment',paymentRoutes);

app.use(errorHandler);

const PORT = process.env.PORT || 3000;
const startServer = async () => {
    try {
        await require('./config/db'); 
        await seedPermissionsAndRoles(); 
        app.listen(PORT, () => {
            console.log(`Server running on port ${PORT}`);
        });
    } catch (error) {
        console.error('Failed to start server:', error);
    }
};

startServer();

File: middleware\asynchandler.js
----------------------------------------
const asyncHandler = fn => (req,res,next) => {
    Promise.resolve(fn(req,res,next)).catch(next);
}
module.exports = asyncHandler

File: middleware\auth.js
----------------------------------------
const jwt = require('jsonwebtoken');
const User = require('../models/user');
const asyncHandler = require('./asynchandler');

const protect = asyncHandler(async (req, res, next) => {
    let token;

    if (
        req.headers.authorization &&
        req.headers.authorization.startsWith('Bearer')
    ) {
        token = req.headers.authorization.split(' ')[1];
    }
    if (!token) {
        return res.status(401).json({
            message: 'Not authorized, no token'
        });
    }

    try {
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        req.user = await User.findById(decoded.id)
        .select('-password')
        .populate({
            path: 'roles',
            populate: {
                path: 'permissions',
                model: 'Permission'
            }
        });
        if (!req.user) {
            return res.status(401).json({
                message: 'Not authorized, user not found'
            });
        }

        next();
    } catch (error) {
        console.error('Auth error:', error);
        res.status(401).json({
            message: 'Not authorized, token failed'
        });
    }
});

const authorize = (...requiredPermissions) => {
    return asyncHandler(async (req, res, next) => {
        const userPermissions = req.user.roles.flatMap(role => role.permissions.map(p => p.name));
        const hasPermission = requiredPermissions.every(permission => userPermissions.includes(permission));
        if (!hasPermission) {
            return res.status(403).json({ message: 'You do not have  required permissions' });
        }
        next();
    });
};

module.exports = { protect, authorize };


File: middleware\errorHandler.js
----------------------------------------
const CustomError = require("../util/customError");

const errorHandler = (err,req,res,next) => {
    console.error('Error:' ,err);

    if(err instanceof CustomError) {
        return CustomError.handleError(err,res);
    }

    res.status(500).json({
        success: false,
        message: 'Something went wrong'
    });
}

module.exports = errorHandler;

File: middleware\rateLimit.js
----------------------------------------
const rateLimit = require('express-rate-limit');

const limiter = rateLimit({
    windowMs: 15 * 60 * 1000,
    max: 100,
    message:
        'Too many requests from this '
});

module.exports = limiter;


File: middleware\upload.js
----------------------------------------
const multer = require('multer');
const path = require('path');
const fs = require('fs');

const uploadDirectory = path.join(__dirname, '..', 'uploads');
if (!fs.existsSync(uploadDirectory)) {
    fs.mkdirSync(uploadDirectory, { recursive: true });
}

const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        cb(null, uploadDirectory);
    },
    filename: (req, file, cb) => {
        const uniqueSuffix = `${Date.now()}-${Math.round(
            Math.random() * 1e9
        )}${path.extname(file.originalname)}`;
        cb(null, `${uniqueSuffix}`);
    }
});

const fileFilter = (req, file, cb) => {
    const allowedMimeTypes = [
        'image/jpeg',
        'image/jpg',
        'image/png',
        'application/pdf',
        'application/msword',
        'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
    ];

    if (allowedMimeTypes.includes(file.mimetype)) {
        cb(null, true);
    } else {
        cb(
            new Error(
                'Unsupported file type. Only images and documents are allowed.'
            )
        );
    }
};

const upload = multer({
    storage,
    limits: { fileSize: 5 * 1024 * 1024 },
    fileFilter
});

module.exports = {
    uploadSingle: upload.single('attachment'),
};


File: models\auditLog.js
----------------------------------------
const mongoose = require('mongoose');

const auditLogSchema = new mongoose.Schema({
    action: {
        type: String,
        required: true
    },
    performedBy: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: true
    },
    entity: {
        type: String,
        required: true
    },
    entityId: {
        type: mongoose.Schema.Types.ObjectId,
        required: true
    },
    changes: {
        type: Object
    },
    timestamp: {
        type: Date,
        default: Date.now
    }
});

module.exports = mongoose.model('AuditLog', auditLogSchema);


File: models\comment.js
----------------------------------------
const mongoose = require('mongoose');

const attachmentSchema = new mongoose.Schema({
    filename: String,
    filepath: String
});

const commentSchema = new mongoose.Schema({
    text: {
        type: String,
        required: true,
        trim: true
    },
    createdBy: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: true
    },
    task: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Task',
        required: true
    },
    createdAt: {
        type: Date,
        default: Date.now
    },
    attachments: [attachmentSchema]
});

module.exports = mongoose.model('Comment', commentSchema);


File: models\payment.js
----------------------------------------
const mongoose = require('mongoose');

const paymentSchema = new mongoose.Schema({
    tier:{
        type: String,
        required: true ,

    },amount:{
        type: Number,
        required: true
    },
    paymentDate:{
        type: Date,
        default: Date.now
    },
    nextPaymentDate:{
        type: Date,
        required: true,
    },
    paymentType:{
        type: String,
        required: true,
        enum:["credit","debit"],
        default: "credit"
    }
});

module.exports = mongoose.model('Payment', paymentSchema)

File: models\permission.js
----------------------------------------
const mongoose = require('mongoose');

const permissionSchema = new mongoose.Schema({
    name: {
        type: String,
        required: true,
        unique: true,
        trim: true
    },
    description: {
        type: String,
        trim: true
    },
    createdAt: {
        type: Date,
        default: Date.now
    }
});

module.exports = mongoose.model('Permission', permissionSchema);


File: models\role.js
----------------------------------------
const mongoose = require('mongoose');

const roleSchema = new mongoose.Schema({
    name: {
        type: String,
        required: true,
        unique: true,
        trim: true
    },
    permissions: [
        {
            type: mongoose.Schema.Types.ObjectId,
            ref: 'Permission',
            required: false
        }
    ],
    createdAt: {
        type: Date,
        default: Date.now
    }
});

module.exports = mongoose.model('Role', roleSchema);


File: models\status.js
----------------------------------------
const mongoose = require('mongoose');

const statusSchema = new mongoose.Schema({
    statusName: {
        type: String,
        required: true,
        unique: true,
        trim: true
    },
    createdBy: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: true
    },
    isDeleted: {
        type: Boolean,
        default: false
    },
    deletedAt: Date,
    nextStatuses: [
        {
            type: mongoose.Schema.Types.ObjectId,
            ref: 'Status'
        }
    ],
    prevStatuses: [
        {
            type: mongoose.Schema.Types.ObjectId,
            ref: 'Status'
        }
    ],
    createdAt: {
        type: Date,
        default: Date.now
    },
    modifiedAt: Date
});

module.exports = mongoose.model('Status', statusSchema);


File: models\task.js
----------------------------------------
const mongoose = require('mongoose');

const taskSchema = new mongoose.Schema({
    title: {
        type: String,
        required: true,
        trim: true
    },
    description: String,
    status: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Status',
        required: true
    },
    createdDate: {
        type: Date,
        default: Date.now
    },
    endDate: Date,
    modifiedDate: Date,
    user: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: true
    },
    assignedTo: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User'
    },
    comments: [
        {
            type: mongoose.Schema.Types.ObjectId,
            ref: 'Comment'
        }
    ],
    priority: {
        type: String,
        enum: ['low', 'medium', 'high'],
        default: 'low'
    },
    isDeleted: {
        type: Boolean,
        default: false
    },
    deletedDate: {
        type: Date
    }
});

module.exports = mongoose.model('Task', taskSchema);


File: models\user.js
----------------------------------------
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const userSchema = new mongoose.Schema({
    username: {
        type: String,
        required: true,
        unique: true,
        trim: true
    },
    email: { 
        type: String,
        required: false,
        unique: true,
        trim: true
    },
    password: {
        type: String,
        required: true
    },
    roles: [
        {
            type: mongoose.Schema.Types.ObjectId,
            ref: 'Role',
            required: false
        }
    ],
    createdAt: {
        type: Date,
        default: Date.now
    },
    isPayed:{
        type:Boolean,
        required:true,
        default:false
    }
});

userSchema.pre('save', async function (next) {
    if (!this.isModified('password')) return next();
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
});

userSchema.methods.matchPassword = async function (
    enteredPassword
) {
    return await bcrypt.compare(enteredPassword, this.password);
};

module.exports = mongoose.model('User', userSchema);


File: repositories\auditLog.js
----------------------------------------
const BaseRepository = require('./baseRepository');
const AuditLog = require('../models/auditLog');
const CustomError = require('../util/customError');

class AuditLogRepository extends BaseRepository {
    constructor() {
        console.log("AuditLog Repository created");
        super(AuditLog);
    }

    async getLogs(filter = {}) {
        try {
            const logs = await this.model.find(filter)
                .populate('performedBy', 'username roles')
                .sort({ timestamp: -1 });
                
            return logs;
        } catch (error) {
            throw new CustomError(`Error fetching audit logs: ${error.message}`);
        }
    }
}

module.exports = AuditLogRepository;


File: repositories\baseRepository.js
----------------------------------------
const CustomError = require("../util/customError");

class BaseRepository {
    constructor(model) {
        this.model = model;
    }

    async create(data) {
        try {
            const doc = await this.model.create(data);
            return doc;
        } catch (error) {
            throw new CustomError(
                `Error creating ${this.model.modelName}: ${error.message}`
            );
        }
    }

    async findAll(filter = {}, options = {}) {
        try {
            const docs = await this.model
                .find(filter)
                .skip(options.skip || 0)
                .limit(options.limit || 100)
                .sort(options.sort || { createdAt: -1 });
            return docs;
        } catch (error) {
            throw new CustomError(
                `Error fetching ${this.model.modelName}s: ${error.message}`
            );
        }
    }

    async findById(id, populate = '') {
        console.log('@!@!@!@! reached bas repository');
        try {
            const doc = await this.model.findById(id).populate(populate);
            return doc;
        } catch (error) {
            throw new CustomError(
                `${this.model.modelName} not found with id ${id}`
            );
        }
    }

    async update(id, data) {
        try {
            const updatedDoc = await this.model.findByIdAndUpdate(
              id,
                data,
                { new: true, runValidators: true }
            );
            return updatedDoc;
        } catch (error) {
            throw new CustomError(
                `Error updating ${this.model.modelName}: ${error.message}`
            );
        }
    }

    async delete(id) {
        try {
            await this.model.findByIdAndDelete(id);
            return true;
        } catch (error) {
            throw new CustomError(
                `Error deleting ${this.model.modelName}: ${error.message}`
            );
        }
    }
}

module.exports = BaseRepository;


File: repositories\baseRepositoryWithSoftDelete.js
----------------------------------------
const BaseRepository = require('./baseRepository');

class BaseRepositoryWithSoftDelete extends BaseRepository {
    constructor(model) {
        super(model);
    }

    async softDelete(id) {
        try {
            const doc = await this.model.findById(id);
            if (!doc) throw new Error(`${this.model.modelName} not found with id ${id}`);
            doc.isDeleted = true;
            doc.deletedDate = new Date();
            await doc.save();
            return doc;
        } catch (error) {
            throw new Error(`Error soft deleting ${this.model.modelName}: ${error.message}`);
        }
    }

    async restore(id) {
        try {
            const doc = await this.model.findById(id);
            if (!doc) throw new Error(`${this.model.modelName} not found with id ${id}`);
            doc.isDeleted = false;
            doc.deletedDate = null;
            await doc.save();
            return doc;
        } catch (error) {
            throw new Error(`Error restoring ${this.model.modelName}: ${error.message}`);
        }
    }

    async findAllDeleted() {
        try {
            const docs = await this.model.find({ isDeleted: true });
            return docs;
        } catch (error) {
            throw new Error(`Error fetching deleted ${this.model.modelName}s: ${error.message}`);
        }
    }
}

module.exports = BaseRepositoryWithSoftDelete;


File: repositories\comment.js
----------------------------------------
const Comment = require('../models/comment');
const BaseRepository = require('./baseRepository');
const CustomError = require('../util/customError')

class CommentRepository extends BaseRepository {
    constructor() {
        super(Comment);
    }

    async addAttachments(commentId, attachments) {
        const comment = await this.findById(commentId);
        if (!comment) {
            throw new CustomError('Comment not found');
        }

        comment.attachments.push(...attachments);
        return await comment.save();
    }
}

module.exports = CommentRepository;


File: repositories\payment.js
----------------------------------------
const BaseRepository = require('./baseRepository');
const Payment = require('../models/payment');
const CustomError = require('../util/customError');


class PaymentRepository extends BaseRepository {

    constructor(model){
        super(Payment);
    }

    async createPayment(paymentData){
        try {
            const payment = await this.create(paymentData);
            return payment;
        } catch (error) {
                return new CustomError(`Error in creating ${error.message}`);
        }
    }

    async getPaymentsByUser(userId) {
        try {
            return await this.model.find({ user: userId });
        } catch (error) {
            throw new CustomError(`Error fetching payments for user ${userId}, ${error.message}`);
        }
    }

    async getOverduePayments() {
        try {
            const currentDate = new Date();
            const overduePayments = await this.model.find({nextPaymentDate: {$lt: currentDate}}).populate('user');
        } catch (error) {
            throw new CustomError(`Error fetching overdue payments ${error}`);
        }
    }
}

module.exports = PaymentRepository;

File: repositories\permission.js
----------------------------------------
const BaseRepository = require('./baseRepositoryWithSoftDelete');
const Permission = require('../models/permission');

class PermissionRepository extends BaseRepository {
    constructor() {
        super(Permission);
    }

    async findByName(name) {
        return await this.model.findOne({name});
    }
}

module.exports = PermissionRepository;

File: repositories\role.js
----------------------------------------
const BaseRepository = require('./baseRepository');
const Role = require('../models/role');

class RoleRepository extends BaseRepository {
    constructor() {
        super(Role);
    }

    async findByName(name) {
        return await this.model.findOne({ name }).populate('permissions');
    }

    async findById(id) {
        console.log("@!@!@!@! Controle reached here");
        return await this.model.findById(id).populate('permissions');
    }

}

module.exports = RoleRepository;


File: repositories\status.js
----------------------------------------
const BaseRepositoryWithSoftDelete = require('./baseRepositoryWithSoftDelete');
const Status = require('../models/status');
const CustomError = require('../util/customError');

class StatusRepository extends BaseRepositoryWithSoftDelete {
    constructor() {
        super(Status);
    }

    async getAllStatus() {
        try {
            return await this.model.find({ isDeleted: false })
                .populate('nextStatuses')
                .populate('prevStatuses');
        } catch (error) {
            throw new CustomError(`Error fetching statuses: ${error.message}`);
        }
    }

    async createStatus(statusData) {
        try {
            const newStatus = await this.model.create(statusData);
            return newStatus;
        } catch (error) {
            throw new CustomError(`Error creating status: ${error.message}`);
        }
    }

    async findById(id) {
        try {
            const status = await this.model.findById(id)
                .populate('nextStatuses')
                .populate('prevStatuses');

            if (!status) {
                throw new CustomError('Status not found', 404);
            }

            return status;
        } catch (error) {
            throw new CustomError(`Error finding status by ID: ${error.message}`);
        }
    }

    async updateStatus(id, statusData) {
        try {
            const updatedStatus = await this.model.findByIdAndUpdate(
                id,
                statusData,
                { new: true, runValidators: true }
            ).populate('nextStatuses').populate('prevStatuses');

            if (!updatedStatus) {
                throw new CustomError('Status not found', 404);
            }

            return updatedStatus;
        } catch (error) {
            throw new CustomError(`Error updating status: ${error.message}`);
        }
    }

    async addNextStatus(id, nextStatusId) {
        try {
            const status = await this.findById(id);
            if (!status) {
                throw new CustomError('Status not found', 404);
            }

            if (!status.nextStatuses.includes(nextStatusId)) {
                status.nextStatuses.push(nextStatusId);
                await status.save();
            }

            return status;
        } catch (error) {
            throw new CustomError(`Error adding next status: ${error.message}`);
        }
    }

    async addPrevStatus(id, prevStatusId) {
        try {
            const status = await this.findById(id);
            if (!status) {
                throw new CustomError('Status not found', 404);
            }

            if (!status.prevStatuses.includes(prevStatusId)) {
                status.prevStatuses.push(prevStatusId);
                await status.save();
            }

            return status;
        } catch (error) {
            throw new CustomError(`Error adding previous status: ${error.message}`);
        }
    }

    async validateTransition(currentStatusId, nextStatusId) {
        try {
            const currentStatus = await this.findById(currentStatusId);
            if (!currentStatus) {
                throw new CustomError('Current status not found', 404);
            }

            const isValidTransition = currentStatus.nextStatuses.some(
                (status) => status._id.toString() === nextStatusId
            );

            return isValidTransition;
        } catch (error) {
            throw new CustomError(`Error validating status transition: ${error.message}`);
        }
    }
}

module.exports = StatusRepository;


File: repositories\task.js
----------------------------------------
const BaseRepositoryWithSoftDelete = require('./baseRepositoryWithSoftDelete');
const Task = require('../models/task');
const CustomError = require('../util/customError');

class TaskRepository extends BaseRepositoryWithSoftDelete {
    constructor() {
        super(Task);
    }

    async getAllTasks(userId) {
        return await this.model
            .find({
                $or: [{ user: userId }, { assignedTo: userId }]
            })
            .populate('status comments createdBy');
    }

    async findById(id, userId) {
        const task = await this.model
            .findOne({
                _id: id,
                $or: [{ user: userId }, { assignedTo: userId }]
            })
            .populate('status comments createdBy');

        if (!task) throw new CustomError('Task not found', 404);
        return task;
    }

    async createTask(taskData, user, assignedTo) {
        const taskToCreate = {
            ...taskData,
            user: user._id,
            assignedTo: assignedTo ? assignedTo._id : null,
            createdDate: new Date(),
            status: taskData.status
        };

        const newTask = await this.model.create(taskToCreate);
        return newTask.populate('status');
    }

    async updateTask(id, updatedTask, userId) {
        const task = await this.findById(id, userId);

        task.title = updatedTask.title || task.title;
        task.description = updatedTask.description || task.description;
        task.modifiedDate = new Date();

        return await task.save();
    }

    async updateTaskStatus(taskId, statusId, userId) {
        const task = await this.findById(taskId, userId);

        task.status = statusId;
        task.modifiedDate = new Date();

        return await task.save();
    }

    async assignTask(id, userId, assignedToId) {
        const task = await this.model.findOne({ _id: id, user: userId });
        if (!task) throw new CustomError('Task not found or unauthorized');

        task.assignedTo = assignedToId;
        return await task.save();
    }

    async deleteTask(id, userId) {
        const task = await this.findById(id, userId);
        await task.remove();
        return task;
    }

    async softDeleteTask(id, userId) {
        const task = await this.findById(id, userId);
        task.isDeleted = true;
        task.deletedDate = new Date();
        return await task.save();
    }

    async restoreTask(id, userId) {
        const task = await this.model.findOne({
            _id: id,
            isDeleted: true,
            $or: [{ user: userId }, { assignedTo: userId }]
        });

        if (!task) throw new CustomError('Task not found or unauthorized');

        task.isDeleted = false;
        task.deletedDate = null;

        return await task.save();
    }

    async getDeletedTasks(userId) {
        return await this.model.find({
            isDeleted: true,
            $or: [{ user: userId }, { assignedTo: userId }]
        }).populate('status');
    }

    async getTasksByPriority(userId, priority) {
        const validPriorities = ['low', 'medium', 'high'];
        if (!validPriorities.includes(priority)) {
            throw new CustomError('Invalid priority value');
        }

        return await this.model
            .find({
                $or: [{ user: userId }, { assignedTo: userId }],
                priority: priority
            })
            .populate('status');
    }

    async updateTaskPriority(id, userId, priority) {
        const task = await this.findById(id, userId);

        const validPriorities = ['low', 'medium', 'high'];
        if (!validPriorities.includes(priority)) {
            throw new CustomError('Invalid priority value');
        }

        task.priority = priority;
        task.modifiedDate = new Date();

        return await task.save();
    }

    async getTasksAssignedTo(userId) {
        return await this.model
            .find({
                assignedTo: userId
            })
            .populate('status');
    }

    async getTasksCreatedBy(userId) {
        return await this.model
            .find({
                user: userId
            })
            .populate('status');
    }

    async getOverdueTasks(userId) {
        const today = new Date();

        return await this.model
            .find({
                $or: [{ user: userId }, { assignedTo: userId }],
                endDate: { $lt: today },
                status: { $ne: 'completed' }
            })
            .populate('status');
    }

    async getTasksDueToday(userId) {
        const startOfDay = new Date();
        startOfDay.setHours(0, 0, 0, 0);

        const endOfDay = new Date();
        endOfDay.setHours(23, 59, 59, 999);

        return await this.model
            .find({
                $or: [{ user: userId }, { assignedTo: userId }],
                endDate: { $gte: startOfDay, $lte: endOfDay }
            })
            .populate('status');
    }

    async searchTasks(userId, searchTerm) {
        return await this.model
            .find({
                $or: [{ user: userId }, { assignedTo: userId }],
                $or: [
                    { title: new RegExp(searchTerm, 'i') },
                    { description: new RegExp(searchTerm, 'i') }
                ]
            })
            .populate('status');
    }

    async unassignTask(id, userId) {
        const task = await this.model.findOne({ _id: id, user: userId });
        if (!task) throw new CustomError('Task not found or unauthorized');

        task.assignedTo = null;

        return await task.save();
    }

    async updateTaskEndDate(id, userId, endDate) {
        const task = await this.findById(id, userId);

        task.endDate = endDate;
        task.modifiedDate = new Date();

        return await task.save();
    }
}

module.exports = TaskRepository;


File: repositories\user.js
----------------------------------------
const BaseRepository = require('./baseRepository');
const User = require('../models/user');
const CustomError = require('../util/customError');

class UserRepository extends BaseRepository {
    constructor() {
        super(User);
    }

    async findByUsername(username) {
        try {
            return await this.model.findOne({ username });
        } catch (error) {
            throw new CustomError(`Error finding user by username: ${error.message}`);
        }
    }

    async validateUser(username, password) {
        const user = await this.findByUsername(username);
        if (user && await user.matchPassword(password)) {
            return user;
        }
        return null;
    }

    async createUser(userData) {
        try {
            const newUser = await this.create(userData);
            return newUser;
        } catch (error) {
            throw new CustomError(`Failed to create the user: ${error.message}`);
        }
    }

    async getAllAdmins() {
        return await this.model.find({ roles: 'admin' }).select('username roles');
    }

    async getUserByIds(userIds) {
        const users = await this.model.find({ _id: { $in: userIds } }).populate({
            path: 'roles',
            populate: {
                path: 'permissions',
                model: 'Permission'
            }
        });

        if (!users) {
            throw new CustomError('Users not found or error in fetching', 404);
        }
        return users;
    }

    async getUserById(id) {
        const query = this.model.findById(id);
        const user = await query.populate({
            path: 'roles',
            populate: {
                path: 'permissions',
                model: 'Permission'
            }
        });
        if (!user) {
            throw new CustomError('User not found');
        }
        return user;
    }
}

module.exports = UserRepository;


File: routes\comment.js
----------------------------------------
const express = require('express');
const CommentController = require('../controllers/comment');
const { protect } = require('../middleware/auth');
const { uploadMultiple } = require('../middleware/upload');

const router = express.Router();
const commentController = new CommentController();

router.post(
    '/tasks/:taskId/comments',
    protect,
    uploadMultiple,
    commentController.addComment
);

router.post(
    '/comments/:commentId/attachments',
    protect,
    uploadMultiple,
    commentController.addAttachmentsToComment
);

router.get(
    '/comments/:commentId/attachments/:attachmentId/download',
    protect,
    commentController.downloadAttachment
);

router.delete(
    '/comments/:commentId/attachments/:attachmentId',
    protect,
    commentController.deleteAttachment
);

module.exports = router;


File: routes\payment.js
----------------------------------------
const {paymentController} = require('../bootstrap'); 
const express = require('express');
const router = express.Router();

const {protect} = require('../middleware/auth');

router.post('/',protect,paymentController.createPayment);
router.get('/',protect,paymentController.getUserPayments);

console.log('Payment route is created');

module.exports = router;

File: routes\role.js
----------------------------------------
const express = require('express');
const { roleController } = require('../bootstrap');
const { protect, authorize } = require('../middleware/auth');

const router = express.Router();

router.post('/', roleController.createRole);
router.get('/', protect, roleController.getAllRoles);
router.get('/:id', protect, roleController.getRoleById);

module.exports = router;


File: routes\status.js
----------------------------------------
const express = require('express');
const { statusController } = require('../bootstrap');
const { protect } = require('../middleware/auth');
const router = express.Router();

console.log('Status router created in the routes');

router.get('/', protect, statusController.getAllStatus);
router.get('/deleted', protect, statusController.getDeletedStatuses);
router.get('/:id', protect, statusController.findStatusById);
router.post('/', protect, statusController.createStatus);
router.delete('/:id', protect, statusController.deleteStatus);
router.post('/:id/restore', protect, statusController.restoreStatus);
router.delete('/:id/hard-delete', protect, statusController.hardDeleteStatus);
router.put('/:id', protect, statusController.modifyStatus);
router.post('/:id/next-status', protect, statusController.addNextStatus);
router.post('/:id/prev-status', protect, statusController.addPrevStatus);
router.get('/validate-transition/:currentStatusId/:nextStatusId', protect, statusController.validateTransition);

module.exports = router;


File: routes\task.js
----------------------------------------
const express = require('express');
const { taskController } = require('../bootstrap');
const { protect, authorize } = require('../middleware/auth');
const router = express.Router();

console.log('Task router created');

router.get('/', protect, authorize('VIEW_TASKS'), taskController.getAllTasks);
router.get('/assigned', protect, taskController.getTasksAssignedTo);
router.get('/created', protect, taskController.getTasksCreatedBy);
router.get('/deleted', protect, taskController.getDeletedTasks);
router.get('/overdue', protect, taskController.getOverdueTasks);
router.get('/due-today', protect, taskController.getTasksDueToday);
router.get('/priority/:priority', protect, taskController.getTasksByPriority);
// router.get('/status/:statusId', protect, taskController.getTasksByStatus);
router.get('/search/:searchTerm', protect, taskController.searchTasks);
router.get('/:id', protect, taskController.getTaskById);

router.post('/', protect, authorize('CREATE_TASK'), taskController.createTask);
router.post('/:id/assign', protect, taskController.assignTask);
router.post('/:id/unassign', protect, taskController.unassignTask);
router.post('/:id/restore', protect, taskController.restoreTask);
// router.post('/date-range', protect, taskController.getTasksByDateRange);

router.put('/:id', protect, authorize('UPDATE_TASK'), taskController.updateTask);
router.put('/:id/end-date', protect, taskController.updateTaskEndDate);
router.put('/:id/priority', protect, taskController.updateTaskPriority);
router.put('/:taskId/status/:statusId', protect, taskController.updateTaskStatus);

router.delete('/:id', protect, authorize('DELETE_TASK'), taskController.deleteTask);
router.delete('/:id/soft-delete', protect, taskController.softDeleteTask);

module.exports = router;


File: routes\user.js
----------------------------------------
const express = require('express');
const { userController } = require('../bootstrap');
const { protect } = require('../middleware/auth');
const limiter = require('../middleware/rateLimit');

const router = express.Router();
console.log('User router created');

router.post('/register', limiter, userController.registerUser);

router.post('/login', limiter, userController.loginUser);

router.get('/:id', protect, userController.getUserById);
router.get('/', protect, userController.getAllUsers);
router.post('/assign-role', protect, userController.assignRole);

module.exports = router;


File: script.js
----------------------------------------
const fs = require('fs');
const path = require('path');

var num = 0;

// Directory to start scanning
const startDir = './'; // Change this to your starting directory if needed
const outputFilePath = 'output.txt';

// Function to get all .js files from a directory recursively
function getAllJsFiles(dir, fileList = []) {
  const files = fs.readdirSync(dir);

  files.forEach((file) => {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);

    if (stat.isDirectory() && file !== 'node_modules') {
      getAllJsFiles(filePath, fileList);
    } else if (path.extname(file) === '.js') {
      fileList.push(filePath);
    }
  });

  return fileList;
}

// Function to write all .js file names, paths, and content to a .txt file
function writeJsFilesToTxt(jsFiles, outputFile) {
  const writeStream = fs.createWriteStream(outputFile);

  jsFiles.forEach((filePath) => {
    const content = fs.readFileSync(filePath, 'utf8');
    writeStream.write(`File: ${filePath}\n`);
    writeStream.write('----------------------------------------\n');
    writeStream.write(`${content}\n\n`);
    num  = num +1;
  });


  writeStream.end();
}

// Main process
try {
  const jsFiles = getAllJsFiles(startDir);
  writeJsFilesToTxt(jsFiles, outputFilePath);
  console.log(`All JavaScript files have been written to ${outputFilePath}`);
  console.log(num);
} catch (err) {
  console.error('Error:', err);
}

File: seed.js
----------------------------------------
const Permission = require('./models/permission');
const Role = require('./models/role');

const seedPermissionsAndRoles = async () => {
    const permissions = [
        { name: 'VIEW_TASKS', description: 'View all tasks' },
        { name: 'CREATE_TASK', description: 'Create new task' },
        { name: 'UPDATE_TASK', description: 'Update existing task' },
        { name: 'DELETE_TASK', description: 'Delete task' }
    ];

    for (const permissionData of permissions) {
        const existingPermission = await Permission.findOne({ name: permissionData.name });
        if (!existingPermission) {
            await Permission.create(permissionData);
        }
    }

    const roles = [
        { name: 'admin', permissions: ['VIEW_TASKS', 'CREATE_TASK', 'UPDATE_TASK', 'DELETE_TASK'] },
        { name: 'user', permissions: ['VIEW_TASKS'] }
    ];

    for (const roleData of roles) {
        const existingRole = await Role.findOne({ name: roleData.name });
        if (!existingRole) {
            const rolePermissions = await Permission.find({ name: { $in: roleData.permissions } });
            const newRole = new Role({ name: roleData.name, permissions: rolePermissions.map(p => p._id) });
            await newRole.save();
        }
    }



    console.log('Permissions and roles seeded successfully.');
};


module.exports = seedPermissionsAndRoles;


File: services\auditLog.js
----------------------------------------
const BaseService = require('./baseService');

class AuditLogService extends BaseService {
    constructor(repository) {
        super(repository);
    }

    async getAuditLogs(filter = {}, options = {}) {
        return await this.repository.getLogs(filter, options);
    }

    async create(logData) {
        try {
            const auditLog = await this.repository.create(logData);
            return auditLog;
        } catch (error) {
            throw new CustomError(`Error creating audit log: ${error.message}`);
        }
    }
}

module.exports = AuditLogService;


File: services\baseService.js
----------------------------------------
class BaseService {
    constructor(repository) {
        this.repository = repository;
    }

    async create(data) {
        return await this.repository.create(data);
    }

    async findAll(filter = {}, options = {}) {
        return await this.repository.findAll(filter, options);
    }

    async findById(id, populate = '') {
        return await this.repository.findById(id, populate);
    }

    async update(id, data) {
        return await this.repository.update(id, data);
    }

    async delete(id) {
        return await this.repository.delete(id);
    }
}

module.exports = BaseService;


File: services\comment.js
----------------------------------------
const BaseService = require('./baseService');
const fs = require('fs').promises;

class CommentService extends BaseService {
    constructor(repository) {
        super(repository);
    }

    async addAttachmentToComment(commentId, attachments) {
        return await this.repository.addAttachments(commentId, attachments);
    }

    async deleteAttachment(commentId, attachmentId) {
        const comment = await this.repository.findById(commentId);
        if (!comment) {
            throw new Error('Comment not found');
        }

        const attachment = comment.attachments.id(attachmentId);
        if (!attachment) {
            throw new Error('Attachment not found');
        }

        await fs.unlink(attachment.filepath).catch(err => {
            console.error('Error deleting file:', err);
        });

        attachment.remove();
        return await comment.save();
    }
}

module.exports = CommentService;


File: services\email.js
----------------------------------------
require('dotenv').config();
const nodemailer = require('nodemailer');

const transporter = nodemailer.createTransport({
    service: process.env.EMAIL_SERVICE,
    auth: {
        user: process.env.EMAIL_USER,
        pass: process.env.EMAIL_PASS
    }
});

async function sendEmail(to, subject, text) {
    const mailOptions = {
        from: process.env.EMAIL_USER,
        to,
        subject,
        text
    };

    try {
        await transporter.sendMail(mailOptions);
        console.log(`Email sent to ${to}`);
    } catch (error) {
        console.error('Error sending email:', error);
    }
}

module.exports = {
    sendEmail
};


File: services\payment.js
----------------------------------------
const BaseService = require('./baseService');
const CustomError = require('../util/customError');

class PaymentService extends BaseService {
    constructor(paymentRepository, userService) {
        super(paymentRepository);
        this.userService = userService;
    }

    async getUserPayments(userId) {
        return await this.repository.getPaymentsByUser(userId);
    }

    async createPayment(paymentData, userId) {
        const user = await this.userService.getUserById(userId);
        if (!user) throw new CustomError('User not found', 404);
        paymentData.user = userId;
        const payment = await this.repository.createPayment(paymentData);
        return payment;
    }


    async getOverduePayments() {
        const payments = await this.repository.getOverduePayments();
        const userIds = payments.map(payment => payment.user._id.toString);
        const uniqueUsers = [...new Set(userIds)];
        const users = await this.userService.getUsersById(uniqueUsers);
        return users;
    }
    
}

module.exports = PaymentService;


File: services\role.js
----------------------------------------
const BaseService = require('./baseService');
const CustomError = require('../util/customError');

class RoleService extends BaseService {
    constructor(repository) {
        super(repository);
    }

    async createRole(roleData) {
        const existingRole = await this.repository.findByName(roleData.name);
        console.log('Creating role with data:', roleData);
        
        if (existingRole) {
            throw new CustomError('Role already exists');
        }
        return await this.repository.create(roleData);
    }

    async getAllRoles() {
        return await this.repository.findAll();
    }

    async getRoleByName(roleName) {
        return await this.repository.findByName(roleName);
    }

    async getRoleById(id) {
        return await this.repository.findById(id);
    }
}

module.exports = RoleService;


File: services\status.js
----------------------------------------
const BaseService = require('./baseService');
const CustomError = require('../util/customError');

class StatusService extends BaseService {
    constructor(repository, auditLogService) {
        super(repository);
        this.auditLogService = auditLogService;
    }

    async getAllStatus() {
        return await this.repository.getAllStatus();
    }

    async getDeletedStatuses() {
        return await this.repository.findAllDeleted();
    }

    async findById(id) {
        const status = await this.repository.findById(id);
        if (!status) {
            throw new CustomError('Status not found', 404);
        }
        return status;
    }

    async createStatus(statusData, user) {
        const newStatus = await this.repository.createStatus(statusData);

        await this.auditLogService.create({
            action: 'Status Created',
            performedBy: user._id,
            entity: 'Status',
            entityId: newStatus._id,
            changes: { statusData },
        });

        return newStatus;
    }

    async deleteStatus(id, user) {
        const status = await this.repository.softDelete(id);
        if (!status) {
            throw new CustomError('Status not found', 404);
        }

        await this.auditLogService.create({
            action: 'Status Soft Deleted',
            performedBy: user._id,
            entity: 'Status',
            entityId: id,
        });

        return status;
    }

    async restoreStatus(id, user) {
        const status = await this.repository.restore(id);
        if (!status) {
            throw new CustomError('Status not found', 404);
        }

        await this.auditLogService.create({
            action: 'Status Restored',
            performedBy: user._id,
            entity: 'Status',
            entityId: id,
        });

        return status;
    }

    async hardDeleteStatus(id, user) {
        const status = await this.repository.delete(id);
        if (!status) {
            throw new CustomError('Status not found', 404);
        }

        await this.auditLogService.create({
            action: 'Status Permanently Deleted',
            performedBy: user._id,
            entity: 'Status',
            entityId: id,
        });

        return status;
    }

    async modifyStatus(id, statusData, user) {
        const status = await this.repository.update(id, statusData);
        if (!status) {
            throw new CustomError('Status not found', 404);
        }

        await this.auditLogService.create({
            action: 'Status Modified',
            performedBy: user._id,
            entity: 'Status',
            entityId: id,
            changes: statusData,
        });

        return status;
    }

    async addNextStatus(id, nextStatusId, user) {
        const status = await this.repository.findById(id);
        if (!status) {
            throw new CustomError('Status not found', 404);
        }

        status.nextStatuses.push(nextStatusId);
        await status.save();

        await this.auditLogService.create({
            action: 'Next Status Added',
            performedBy: user._id,
            entity: 'Status',
            entityId: id,
            changes: { nextStatusId },
        });

        return status;
    }

    async addPrevStatus(id, prevStatusId, user) {
        const status = await this.repository.findById(id);
        if (!status) {
            throw new CustomError('Status not found', 404);
        }

        status.prevStatuses.push(prevStatusId);
        await status.save();

        await this.auditLogService.create({
            action: 'Previous Status Added',
            performedBy: user._id,
            entity: 'Status',
            entityId: id,
            changes: { prevStatusId },
        });

        return status;
    }

    async validateTransition(currentStatusId, nextStatusId, user) {
        const currentStatus = await this.repository.findById(currentStatusId);
        if (!currentStatus) {
            throw new CustomError('Current status not found', 404);
        }

        const isValidTransition = currentStatus.nextStatuses.some(
            (status) => status.toString() === nextStatusId
        );

        if (!isValidTransition) {
            throw new CustomError('Invalid status transition', 400);
        }

        await this.auditLogService.create({
            action: 'Status Transition Validated',
            performedBy: user._id,
            entity: 'StatusTransition',
            entityId: `${currentStatusId}->${nextStatusId}`,
        });

        return true;
    }
}

module.exports = StatusService;


File: services\task.js
----------------------------------------

const BaseService = require('./baseService');
const { sendEmail } = require('./email');
const CustomError = require('../util/customError');

class TaskService extends BaseService {
    constructor(taskRepository, commentService, userService, statusService, auditLogService) {
        super(taskRepository);
        this.commentService = commentService;
        this.userService = userService;
        this.statusService = statusService;
        this.auditLogService = auditLogService;
    }

    async getAllTasks(user) {
        return await this.repository.getAllTasks(user._id);
    }

    async findById(id, user) {
        const task = await this.repository.findById(id, user._id);
        if (!task) throw new CustomError('Task not found or unauthorized', 404);
        return task;
    }

    async createTask(taskData, user, assignedToId = null) {
        let assignedTo = null;
        if (assignedToId) {
            assignedTo = await this.userService.getUserById(assignedToId);
            if (!assignedTo) throw new CustomError('Assigned user not found', 404);
        }

        const newTask = await this.repository.createTask(taskData, user, assignedTo);

        if (assignedTo && assignedTo.email) {
            await sendEmail(
                assignedTo.email,
                'New Task Assigned',
                `You have been assigned a new task: ${taskData.title}`
            );
        }

        return newTask;
    }

    async updateTask(id, taskData, user) {
        return await this.repository.updateTask(id, taskData, user._id);
    }

    async updateTaskStatus(taskId, statusId, user) {
        const status = await this.statusService.findById(statusId);
        if (!status) throw new CustomError('Invalid status', 400);

        const task = await this.repository.updateTaskStatus(taskId, statusId, user._id);

        const taskOwner = await this.userService.getUserById(task.user);
        if (taskOwner && taskOwner.email) {
            await sendEmail(
                taskOwner.email,
                'Task Status Updated',
                `Your task "${task.title}" status has been updated to "${status.statusName}".`
            );
        }

        return task;
    }

    async deleteTask(id, user) {
        return await this.repository.deleteTask(id, user._id);
    }

    async assignTask(id, userId, assignedToId) {
        const task = await this.repository.assignTask(id, userId, assignedToId);

        const assignedToUser = await this.userService.getUserById(assignedToId);
        if (assignedToUser && assignedToUser.email) {
            await sendEmail(
                assignedToUser.email,
                'Task Assigned',
                `You have been assigned a task: ${task.title}`
            );
        }
        return task;
    }

    async softDeleteTask(id, user) {
        return await this.repository.softDeleteTask(id, user._id);
    }

    async restoreTask(id, user) {
        return await this.repository.restoreTask(id, user._id);
    }

    async getDeletedTasks(user) {
        return await this.repository.getDeletedTasks(user._id);
    }

    async getTasksByPriority(user, priority) {
        return await this.repository.getTasksByPriority(user._id, priority);
    }

    async updateTaskPriority(id, user, priority) {
        return await this.repository.updateTaskPriority(id, user._id, priority);
    }

    async getTasksAssignedTo(user) {
        return await this.repository.getTasksAssignedTo(user._id);
    }

    async getTasksCreatedBy(user) {
        return await this.repository.getTasksCreatedBy(user._id);
    }

    async getOverdueTasks(user) {
        return await this.repository.getOverdueTasks(user._id);
    }

    async getTasksDueToday(user) {
        return await this.repository.getTasksDueToday(user._id);
    }

    async searchTasks(user, searchTerm) {
        return await this.repository.searchTasks(user._id, searchTerm);
    }

    async unassignTask(id, user) {
        return await this.repository.unassignTask(id, user._id);
    }

    async updateTaskEndDate(id, user, endDate) {
        return await this.repository.updateTaskEndDate(id, user._id, endDate);
    }
}

module.exports = TaskService;


File: services\user.js
----------------------------------------
const BaseService = require('./baseService');
const { generateToken } = require('../util/jwt');
const CustomError = require('../util/customError');
const { populateRolesAndPermissions } = require('../util/populate');

class UserService extends BaseService {
    constructor(userRepository, roleService, auditLogService) {
        super(userRepository);
        this.roleService = roleService;
        this.auditLogService = auditLogService;
    }

    async registerUser(userData) {
        const existingUser = await this.repository.findByUsername(userData.username);
        if (existingUser) {
            throw new CustomError('User already exists');
        }

        if (!userData.roles) {
            const role = await this.roleService.getRoleByName('user');
            if (!role) {
                throw new CustomError('User role not found', 500);
            }
            userData.roles = [role._id];
        }

        const newUser = await this.repository.createUser(userData);

        await this.auditLogService.create({
            action: 'User Registered',
            performedBy: newUser._id,
            entity: 'User',
            entityId: newUser._id,
            changes: {
                username: newUser.username,
                email: newUser.email,
                roles: newUser.roles
            },
        });

        await populateRolesAndPermissions(newUser);

        const token = await generateToken(newUser._id);

        return {
            _id: newUser._id,
            username: newUser.username,
            email: newUser.email,
            roles: newUser.roles,
            token: 'Bearer ' + token
        };
    }

    async loginUser(username, password) {
        const user = await this.repository.validateUser(username, password);
        if (!user) {
            throw new CustomError('Invalid username or password');
        }

        const foundUser = await this.getUserById(user._id);

        const token = await generateToken(foundUser._id);

        return {
            _id: foundUser._id,
            username: foundUser.username,
            email: foundUser.email,
            roles: foundUser.roles,
            token: 'Bearer ' + token
        };
    }

    async getUserById(id) {
        const query = this.repository.findById(id);
        const user = await populateRolesAndPermissions(query);
        if (!user) {
            throw new CustomError('User not found');
        }
        return user;
    }

    async getAllUsers() {
        const query = this.repository.findAll();
        return await populateRolesAndPermissions(query);
    }

    async assignRole(userId, roleId) {
        const user = await this.repository.findById(userId);
        if (!user) {
            throw new CustomError('User not found');
        }

        const role = await this.roleService.getRoleById(roleId);
        if (!role) {
            throw new CustomError('Role not found');
        }

        if (!user.roles.includes(roleId)) {
            user.roles.push(roleId);
            await user.save();

            await this.auditLogService.create({
                action: 'Role Assigned',
                performedBy: userId,
                entity: 'User',
                entityId: userId,
                changes: {
                    roles: user.roles
                },
            });
        }

        const savedUser = await this.getUserById(userId);
        return savedUser;
    }

    async getUsersById(userIds) {
        const users = await this.repository.getUserByIds(userIds);
        return users;
    }
}

module.exports = UserService;


File: util\customError.js
----------------------------------------
class CustomError extends Error {
    constructor(message, statusCode) {
        if (typeof message !== 'string') {
            message = JSON.stringify(message);
        }
        super(message); 
        this.statusCode = statusCode;
        this.name = 'CustomError'; 
    }

    static handleError(err, res) {
        const status = err.statusCode || 500;
        const responseMessage = err.message || 'An error occurred';
        res.status(status).json({
            success: false,
            message: responseMessage,
        });
    }
}

module.exports = CustomError; 

File: util\jwt.js
----------------------------------------
const jwt = require('jsonwebtoken');

const generateToken = async userId => {
    const token = await jwt.sign({ id: userId }, process.env.JWT_SECRET, {
        expiresIn: '60d'
    });
    return token;
};

module.exports = { generateToken };


File: util\populate.js
----------------------------------------
const populateRolesAndPermissions = (query) => {
    return query.populate({
      path: 'roles',
      populate: {
        path: 'permissions',
        model: 'Permission',
      },
    });
  };
  
  module.exports = {
    populateRolesAndPermissions,
  };

